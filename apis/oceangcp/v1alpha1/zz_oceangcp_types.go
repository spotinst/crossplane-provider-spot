// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoscalerInitParameters struct {

	// Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	Cooldown *float64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// Auto Scaling scale down operations.
	Down []DownInitParameters `json:"down,omitempty" tf:"down,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	Headroom []HeadroomInitParameters `json:"headroom,omitempty" tf:"headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	IsAutoConfig *bool `json:"isAutoConfig,omitempty" tf:"is_auto_config,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	ResourceLimits []ResourceLimitsInitParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AutoscalerObservation struct {

	// Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	Cooldown *float64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// Auto Scaling scale down operations.
	Down []DownObservation `json:"down,omitempty" tf:"down,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	Headroom []HeadroomObservation `json:"headroom,omitempty" tf:"headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	IsAutoConfig *bool `json:"isAutoConfig,omitempty" tf:"is_auto_config,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	ResourceLimits []ResourceLimitsObservation `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AutoscalerParameters struct {

	// Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	// +kubebuilder:validation:Optional
	Cooldown *float64 `json:"cooldown,omitempty" tf:"cooldown,omitempty"`

	// Auto Scaling scale down operations.
	// +kubebuilder:validation:Optional
	Down []DownParameters `json:"down,omitempty" tf:"down,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	// +kubebuilder:validation:Optional
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	// +kubebuilder:validation:Optional
	Headroom []HeadroomParameters `json:"headroom,omitempty" tf:"headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	// +kubebuilder:validation:Optional
	IsAutoConfig *bool `json:"isAutoConfig,omitempty" tf:"is_auto_config,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type BackendServicesInitParameters struct {

	// Sets which location the backend services will be active. Valid values: regional, global.
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// A list of ports.
	NamedPorts []NamedPortsInitParameters `json:"namedPorts,omitempty" tf:"named_ports,omitempty"`

	// Use when location_type is regional. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: INTERNAL, EXTERNAL.
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`

	// The name of the backend service.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type BackendServicesObservation struct {

	// Sets which location the backend services will be active. Valid values: regional, global.
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// A list of ports.
	NamedPorts []NamedPortsObservation `json:"namedPorts,omitempty" tf:"named_ports,omitempty"`

	// Use when location_type is regional. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: INTERNAL, EXTERNAL.
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`

	// The name of the backend service.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type BackendServicesParameters struct {

	// Sets which location the backend services will be active. Valid values: regional, global.
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// A list of ports.
	// +kubebuilder:validation:Optional
	NamedPorts []NamedPortsParameters `json:"namedPorts,omitempty" tf:"named_ports,omitempty"`

	// Use when location_type is regional. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: INTERNAL, EXTERNAL.
	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`

	// The name of the backend service.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName" tf:"service_name,omitempty"`
}

type ClusterRollInitParameters struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ClusterRollObservation struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ClusterRollParameters struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type DownInitParameters struct {

	// The number of evaluation periods that should accumulate before a scale down action takes place.
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type DownObservation struct {

	// The number of evaluation periods that should accumulate before a scale down action takes place.
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type DownParameters struct {

	// The number of evaluation periods that should accumulate before a scale down action takes place.
	// +kubebuilder:validation:Optional
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	// +kubebuilder:validation:Optional
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type FiltersInitParameters struct {

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`
}

type FiltersObservation struct {

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`
}

type FiltersParameters struct {

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of vcpus available.
	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`
}

type HeadroomInitParameters struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// How much GPU allocate for headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type HeadroomObservation struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// How much GPU allocate for headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type HeadroomParameters struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// How much GPU allocate for headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate the headroom.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type NamedPortsInitParameters struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// A list of ports.
	Ports []*string `json:"ports,omitempty" tf:"ports,omitempty"`
}

type NamedPortsObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// A list of ports.
	Ports []*string `json:"ports,omitempty" tf:"ports,omitempty"`
}

type NamedPortsParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// A list of ports.
	// +kubebuilder:validation:Optional
	Ports []*string `json:"ports" tf:"ports,omitempty"`
}

type OceanGcpInitParameters struct {

	// The Ocean Kubernetes Autoscaler object.
	Autoscaler []AutoscalerInitParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Describes the backend service configurations.
	BackendServices []BackendServicesInitParameters `json:"backendServices,omitempty" tf:"backend_services,omitempty"`

	// Instance types to avoid launching in the Ocean cluster. Cannot be configured if whitelist list is configured.
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// The GKE cluster name.
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	ControllerClusterID *string `json:"controllerClusterId,omitempty" tf:"controller_cluster_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	Filters []FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The zone the master cluster is located in.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The root volume disk type.
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Set scheduling object.
	ScheduledTask []ScheduledTaskInitParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// The Ocean shielded instance configuration object.
	ShieldedInstanceConfig []ShieldedInstanceConfigInitParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Strategy object.
	Strategy []StrategyInitParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	UpdatePolicy []UpdatePolicyInitParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist list is configured.
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type OceanGcpObservation struct {

	// The Ocean Kubernetes Autoscaler object.
	Autoscaler []AutoscalerObservation `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Describes the backend service configurations.
	BackendServices []BackendServicesObservation `json:"backendServices,omitempty" tf:"backend_services,omitempty"`

	// Instance types to avoid launching in the Ocean cluster. Cannot be configured if whitelist list is configured.
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// The Spotinst Ocean ID.
	ClusterControllerID *string `json:"clusterControllerId,omitempty" tf:"cluster_controller_id,omitempty"`

	// The GKE cluster name.
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	ControllerClusterID *string `json:"controllerClusterId,omitempty" tf:"controller_cluster_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// The Spotinst Ocean ID.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The zone the master cluster is located in.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The root volume disk type.
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Set scheduling object.
	ScheduledTask []ScheduledTaskObservation `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// The Ocean shielded instance configuration object.
	ShieldedInstanceConfig []ShieldedInstanceConfigObservation `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Strategy object.
	Strategy []StrategyObservation `json:"strategy,omitempty" tf:"strategy,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist list is configured.
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type OceanGcpParameters struct {

	// The Ocean Kubernetes Autoscaler object.
	// +kubebuilder:validation:Optional
	Autoscaler []AutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Describes the backend service configurations.
	// +kubebuilder:validation:Optional
	BackendServices []BackendServicesParameters `json:"backendServices,omitempty" tf:"backend_services,omitempty"`

	// Instance types to avoid launching in the Ocean cluster. Cannot be configured if whitelist list is configured.
	// +kubebuilder:validation:Optional
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// The GKE cluster name.
	// +kubebuilder:validation:Optional
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	// +kubebuilder:validation:Optional
	ControllerClusterID *string `json:"controllerClusterId,omitempty" tf:"controller_cluster_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	// +kubebuilder:validation:Optional
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The zone the master cluster is located in.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The root volume disk type.
	// +kubebuilder:validation:Optional
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Set scheduling object.
	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// The Ocean shielded instance configuration object.
	// +kubebuilder:validation:Optional
	ShieldedInstanceConfig []ShieldedInstanceConfigParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Strategy object.
	// +kubebuilder:validation:Optional
	Strategy []StrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	// +kubebuilder:validation:Optional
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist list is configured.
	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type ResourceLimitsInitParameters struct {

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceLimitsObservation struct {

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceLimitsParameters struct {

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type RollConfigInitParameters struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// List of Virtual Node Group identifiers to be rolled.
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type RollConfigObservation struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// List of Virtual Node Group identifiers to be rolled.
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type RollConfigParameters struct {

	// Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value in % to set size of batch in roll. Valid values are 0-100
	// Example: 20.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// List of Virtual Node Group identifiers to be rolled.
	// +kubebuilder:validation:Optional
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ScheduledTaskInitParameters struct {

	// Set shutdown hours for cluster object.
	ShutdownHours []ShutdownHoursInitParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	Tasks []TasksInitParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ScheduledTaskObservation struct {

	// Set shutdown hours for cluster object.
	ShutdownHours []ShutdownHoursObservation `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	Tasks []TasksObservation `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ScheduledTaskParameters struct {

	// Set shutdown hours for cluster object.
	// +kubebuilder:validation:Optional
	ShutdownHours []ShutdownHoursParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	// +kubebuilder:validation:Optional
	Tasks []TasksParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ShieldedInstanceConfigInitParameters struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type ShieldedInstanceConfigObservation struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type ShieldedInstanceConfigParameters struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	// +kubebuilder:validation:Optional
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	// +kubebuilder:validation:Optional
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type ShutdownHoursInitParameters struct {

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = true. API Times are in UTC
	// Example: Fri:15:30-Wed:14:30
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type ShutdownHoursObservation struct {

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = true. API Times are in UTC
	// Example: Fri:15:30-Wed:14:30
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type ShutdownHoursParameters struct {

	// Flag to enable / disable the shutdown hours.
	// Example: true
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = true. API Times are in UTC
	// Example: Fri:15:30-Wed:14:30
	// +kubebuilder:validation:Optional
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type StrategyInitParameters struct {

	// The draining timeout (in seconds) before terminating the instance.
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Defines the desired preemptible percentage for the cluster.
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Define the provisioning model of the launched instances. Valid values: SPOT, PREEMPTIBLE.
	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	// Enable committed use discounts utilization.
	ShouldUtilizeCommitments *bool `json:"shouldUtilizeCommitments,omitempty" tf:"should_utilize_commitments,omitempty"`
}

type StrategyObservation struct {

	// The draining timeout (in seconds) before terminating the instance.
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Defines the desired preemptible percentage for the cluster.
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Define the provisioning model of the launched instances. Valid values: SPOT, PREEMPTIBLE.
	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	// Enable committed use discounts utilization.
	ShouldUtilizeCommitments *bool `json:"shouldUtilizeCommitments,omitempty" tf:"should_utilize_commitments,omitempty"`
}

type StrategyParameters struct {

	// The draining timeout (in seconds) before terminating the instance.
	// +kubebuilder:validation:Optional
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Defines the desired preemptible percentage for the cluster.
	// +kubebuilder:validation:Optional
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Define the provisioning model of the launched instances. Valid values: SPOT, PREEMPTIBLE.
	// +kubebuilder:validation:Optional
	ProvisioningModel *string `json:"provisioningModel,omitempty" tf:"provisioning_model,omitempty"`

	// Enable committed use discounts utilization.
	// +kubebuilder:validation:Optional
	ShouldUtilizeCommitments *bool `json:"shouldUtilizeCommitments,omitempty" tf:"should_utilize_commitments,omitempty"`
}

type TaskParametersInitParameters struct {

	// The cluster roll parameters for the cluster.
	ClusterRoll []ClusterRollInitParameters `json:"clusterRoll,omitempty" tf:"cluster_roll,omitempty"`
}

type TaskParametersObservation struct {

	// The cluster roll parameters for the cluster.
	ClusterRoll []ClusterRollObservation `json:"clusterRoll,omitempty" tf:"cluster_roll,omitempty"`
}

type TaskParametersParameters struct {

	// The cluster roll parameters for the cluster.
	// +kubebuilder:validation:Optional
	ClusterRoll []ClusterRollParameters `json:"clusterRoll,omitempty" tf:"cluster_roll,omitempty"`
}

type TasksInitParameters struct {

	// A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
	// Example: 0 1 * * *
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The scheduling parameters for the cluster.
	TaskParameters []TaskParametersInitParameters `json:"taskParameters,omitempty" tf:"task_parameters,omitempty"`

	// Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type TasksObservation struct {

	// A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
	// Example: 0 1 * * *
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The scheduling parameters for the cluster.
	TaskParameters []TaskParametersObservation `json:"taskParameters,omitempty" tf:"task_parameters,omitempty"`

	// Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type TasksParameters struct {

	// A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
	// Example: 0 1 * * *
	// +kubebuilder:validation:Optional
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// Flag to enable / disable the shutdown hours.
	// Example: true
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// The scheduling parameters for the cluster.
	// +kubebuilder:validation:Optional
	TaskParameters []TaskParametersParameters `json:"taskParameters,omitempty" tf:"task_parameters,omitempty"`

	// Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
	// +kubebuilder:validation:Optional
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type UpdatePolicyInitParameters struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// Holds the roll configuration.
	RollConfig []RollConfigInitParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyObservation struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// Holds the roll configuration.
	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// Holds the roll configuration.
	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	// +kubebuilder:validation:Optional
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// OceanGcpSpec defines the desired state of OceanGcp
type OceanGcpSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanGcpParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OceanGcpInitParameters `json:"initProvider,omitempty"`
}

// OceanGcpStatus defines the observed state of OceanGcp.
type OceanGcpStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanGcpObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OceanGcp is the Schema for the OceanGcps API. Provides a Spotinst Ocean resource using gke.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type OceanGcp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterName) || (has(self.initProvider) && has(self.initProvider.clusterName))",message="spec.forProvider.clusterName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.location) || (has(self.initProvider) && has(self.initProvider.location))",message="spec.forProvider.location is a required parameter"
	Spec   OceanGcpSpec   `json:"spec"`
	Status OceanGcpStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanGcpList contains a list of OceanGcps
type OceanGcpList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanGcp `json:"items"`
}

// Repository type metadata.
var (
	OceanGcp_Kind             = "OceanGcp"
	OceanGcp_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanGcp_Kind}.String()
	OceanGcp_KindAPIVersion   = OceanGcp_Kind + "." + CRDGroupVersion.String()
	OceanGcp_GroupVersionKind = CRDGroupVersion.WithKind(OceanGcp_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanGcp{}, &OceanGcpList{})
}
