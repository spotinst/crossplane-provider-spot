// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessConfigsInitParameters struct {

	// The launch specification name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The type of the access configuration.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AccessConfigsObservation struct {

	// The launch specification name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The type of the access configuration.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AccessConfigsParameters struct {

	// The launch specification name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The type of the access configuration.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AliasIPRangesInitParameters struct {

	// specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
	IPCidrRange *string `json:"ipCidrRange,omitempty" tf:"ip_cidr_range,omitempty"`

	// specify the IP address range for the subnet secondary IP range.
	SubnetworkRangeName *string `json:"subnetworkRangeName,omitempty" tf:"subnetwork_range_name,omitempty"`
}

type AliasIPRangesObservation struct {

	// specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
	IPCidrRange *string `json:"ipCidrRange,omitempty" tf:"ip_cidr_range,omitempty"`

	// specify the IP address range for the subnet secondary IP range.
	SubnetworkRangeName *string `json:"subnetworkRangeName,omitempty" tf:"subnetwork_range_name,omitempty"`
}

type AliasIPRangesParameters struct {

	// specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
	// +kubebuilder:validation:Optional
	IPCidrRange *string `json:"ipCidrRange" tf:"ip_cidr_range,omitempty"`

	// specify the IP address range for the subnet secondary IP range.
	// +kubebuilder:validation:Optional
	SubnetworkRangeName *string `json:"subnetworkRangeName" tf:"subnetwork_range_name,omitempty"`
}

type AutoscaleHeadroomsAutomaticInitParameters struct {

	// Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.is_enabled = true is set on the Ocean cluster.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`
}

type AutoscaleHeadroomsAutomaticObservation struct {

	// Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.is_enabled = true is set on the Ocean cluster.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`
}

type AutoscaleHeadroomsAutomaticParameters struct {

	// Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.is_enabled = true is set on the Ocean cluster.
	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`
}

type AutoscaleHeadroomsInitParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomsObservation struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomsParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits" tf:"num_of_units,omitempty"`
}

type CreateOptionsInitParameters struct {

	// When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
	InitialNodes *float64 `json:"initialNodes,omitempty" tf:"initial_nodes,omitempty"`
}

type CreateOptionsObservation struct {

	// When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
	InitialNodes *float64 `json:"initialNodes,omitempty" tf:"initial_nodes,omitempty"`
}

type CreateOptionsParameters struct {

	// When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
	// +kubebuilder:validation:Optional
	InitialNodes *float64 `json:"initialNodes,omitempty" tf:"initial_nodes,omitempty"`
}

type LabelsInitParameters struct {

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsObservation struct {

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// The metadata key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MetadataInitParameters struct {

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MetadataObservation struct {

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MetadataParameters struct {

	// The metadata key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NetworkInterfacesInitParameters struct {

	// The network protocol of the VNG.
	AccessConfigs []AccessConfigsInitParameters `json:"accessConfigs,omitempty" tf:"access_configs,omitempty"`

	// use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
	AliasIPRanges []AliasIPRangesInitParameters `json:"aliasIpRanges,omitempty" tf:"alias_ip_ranges,omitempty"`

	// The name of the network.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type NetworkInterfacesObservation struct {

	// The network protocol of the VNG.
	AccessConfigs []AccessConfigsObservation `json:"accessConfigs,omitempty" tf:"access_configs,omitempty"`

	// use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
	AliasIPRanges []AliasIPRangesObservation `json:"aliasIpRanges,omitempty" tf:"alias_ip_ranges,omitempty"`

	// The name of the network.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type NetworkInterfacesParameters struct {

	// The network protocol of the VNG.
	// +kubebuilder:validation:Optional
	AccessConfigs []AccessConfigsParameters `json:"accessConfigs,omitempty" tf:"access_configs,omitempty"`

	// use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
	// +kubebuilder:validation:Optional
	AliasIPRanges []AliasIPRangesParameters `json:"aliasIpRanges,omitempty" tf:"alias_ip_ranges,omitempty"`

	// The name of the network.
	// +kubebuilder:validation:Optional
	Network *string `json:"network" tf:"network,omitempty"`

	// Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type OceanGkeVngInitParameters struct {

	// Set custom headroom per launch spec. provide list of headrooms object.
	AutoscaleHeadrooms []AutoscaleHeadroomsInitParameters `json:"autoscaleHeadrooms,omitempty" tf:"autoscale_headrooms,omitempty"`

	// Set automatic headroom per launch spec.
	AutoscaleHeadroomsAutomatic []AutoscaleHeadroomsAutomaticInitParameters `json:"autoscaleHeadroomsAutomatic,omitempty" tf:"autoscale_headrooms_automatic,omitempty"`

	CreateOptions []CreateOptionsInitParameters `json:"createOptions,omitempty" tf:"create_options,omitempty"`

	// List of supported machine types for the Launch Spec.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	Labels []LabelsInitParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Cluster's metadata.
	Metadata []MetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// The launch specification name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Settings for network interfaces.
	NetworkInterfaces []NetworkInterfacesInitParameters `json:"networkInterfaces,omitempty" tf:"network_interfaces,omitempty"`

	// The node pool you wish to use in your Launch Spec.
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The Ocean cluster ID.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The Ocean virtual node group resource limits object.
	ResourceLimits []ResourceLimitsInitParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`

	// Boolean. When set to true, VNG nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
	RestrictScaleDown *bool `json:"restrictScaleDown,omitempty" tf:"restrict_scale_down,omitempty"`

	// Root volume size (in GB).
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Root volume disk type. Valid values: "pd-standard", "pd-ssd".
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Used to define scheduled tasks such as a manual headroom update.
	SchedulingTask []SchedulingTaskInitParameters `json:"schedulingTask,omitempty" tf:"scheduling_task,omitempty"`

	// The account used by applications running on the VM to call GCP APIs.
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// The Ocean shielded instance configuration object.
	ShieldedInstanceConfig []ShieldedInstanceConfigInitParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Image URL.
	SourceImage *string `json:"sourceImage,omitempty" tf:"source_image,omitempty"`

	// The Ocean virtual node group storage object.
	Storage []StorageInitParameters `json:"storage,omitempty" tf:"storage,omitempty"`

	// The Ocean Launch Spec Strategy object.
	Strategy []StrategyInitParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Every node launched from this configuration will be tagged with those tags. Note: during creation some tags are automatically imported to the state file, it is required to manually add it to the template configuration
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	Taints []TaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	UpdatePolicy []UpdatePolicyInitParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`
}

type OceanGkeVngObservation struct {

	// Set custom headroom per launch spec. provide list of headrooms object.
	AutoscaleHeadrooms []AutoscaleHeadroomsObservation `json:"autoscaleHeadrooms,omitempty" tf:"autoscale_headrooms,omitempty"`

	// Set automatic headroom per launch spec.
	AutoscaleHeadroomsAutomatic []AutoscaleHeadroomsAutomaticObservation `json:"autoscaleHeadroomsAutomatic,omitempty" tf:"autoscale_headrooms_automatic,omitempty"`

	CreateOptions []CreateOptionsObservation `json:"createOptions,omitempty" tf:"create_options,omitempty"`

	// The Spotinst LaunchSpec ID.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// List of supported machine types for the Launch Spec.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	// Cluster's metadata.
	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// The launch specification name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Settings for network interfaces.
	NetworkInterfaces []NetworkInterfacesObservation `json:"networkInterfaces,omitempty" tf:"network_interfaces,omitempty"`

	// The node pool you wish to use in your Launch Spec.
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The Ocean cluster ID.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The Ocean virtual node group resource limits object.
	ResourceLimits []ResourceLimitsObservation `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`

	// Boolean. When set to true, VNG nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
	RestrictScaleDown *bool `json:"restrictScaleDown,omitempty" tf:"restrict_scale_down,omitempty"`

	// Root volume size (in GB).
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Root volume disk type. Valid values: "pd-standard", "pd-ssd".
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Used to define scheduled tasks such as a manual headroom update.
	SchedulingTask []SchedulingTaskObservation `json:"schedulingTask,omitempty" tf:"scheduling_task,omitempty"`

	// The account used by applications running on the VM to call GCP APIs.
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// The Ocean shielded instance configuration object.
	ShieldedInstanceConfig []ShieldedInstanceConfigObservation `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Image URL.
	SourceImage *string `json:"sourceImage,omitempty" tf:"source_image,omitempty"`

	// The Ocean virtual node group storage object.
	Storage []StorageObservation `json:"storage,omitempty" tf:"storage,omitempty"`

	// The Ocean Launch Spec Strategy object.
	Strategy []StrategyObservation `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Every node launched from this configuration will be tagged with those tags. Note: during creation some tags are automatically imported to the state file, it is required to manually add it to the template configuration
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`
}

type OceanGkeVngParameters struct {

	// Set custom headroom per launch spec. provide list of headrooms object.
	// +kubebuilder:validation:Optional
	AutoscaleHeadrooms []AutoscaleHeadroomsParameters `json:"autoscaleHeadrooms,omitempty" tf:"autoscale_headrooms,omitempty"`

	// Set automatic headroom per launch spec.
	// +kubebuilder:validation:Optional
	AutoscaleHeadroomsAutomatic []AutoscaleHeadroomsAutomaticParameters `json:"autoscaleHeadroomsAutomatic,omitempty" tf:"autoscale_headrooms_automatic,omitempty"`

	// +kubebuilder:validation:Optional
	CreateOptions []CreateOptionsParameters `json:"createOptions,omitempty" tf:"create_options,omitempty"`

	// List of supported machine types for the Launch Spec.
	// +kubebuilder:validation:Optional
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Cluster's metadata.
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// The launch specification name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Settings for network interfaces.
	// +kubebuilder:validation:Optional
	NetworkInterfaces []NetworkInterfacesParameters `json:"networkInterfaces,omitempty" tf:"network_interfaces,omitempty"`

	// The node pool you wish to use in your Launch Spec.
	// +kubebuilder:validation:Optional
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The Ocean cluster ID.
	// +kubebuilder:validation:Optional
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The Ocean virtual node group resource limits object.
	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`

	// Boolean. When set to true, VNG nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
	// +kubebuilder:validation:Optional
	RestrictScaleDown *bool `json:"restrictScaleDown,omitempty" tf:"restrict_scale_down,omitempty"`

	// Root volume size (in GB).
	// +kubebuilder:validation:Optional
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Root volume disk type. Valid values: "pd-standard", "pd-ssd".
	// +kubebuilder:validation:Optional
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Used to define scheduled tasks such as a manual headroom update.
	// +kubebuilder:validation:Optional
	SchedulingTask []SchedulingTaskParameters `json:"schedulingTask,omitempty" tf:"scheduling_task,omitempty"`

	// The account used by applications running on the VM to call GCP APIs.
	// +kubebuilder:validation:Optional
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// The Ocean shielded instance configuration object.
	// +kubebuilder:validation:Optional
	ShieldedInstanceConfig []ShieldedInstanceConfigParameters `json:"shieldedInstanceConfig,omitempty" tf:"shielded_instance_config,omitempty"`

	// Image URL.
	// +kubebuilder:validation:Optional
	SourceImage *string `json:"sourceImage,omitempty" tf:"source_image,omitempty"`

	// The Ocean virtual node group storage object.
	// +kubebuilder:validation:Optional
	Storage []StorageParameters `json:"storage,omitempty" tf:"storage,omitempty"`

	// The Ocean Launch Spec Strategy object.
	// +kubebuilder:validation:Optional
	Strategy []StrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Every node launched from this configuration will be tagged with those tags. Note: during creation some tags are automatically imported to the state file, it is required to manually add it to the template configuration
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Optionally adds labels to instances launched in an Ocean cluster.
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`
}

type ResourceLimitsInitParameters struct {

	// Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	MaxInstanceCount *float64 `json:"maxInstanceCount,omitempty" tf:"max_instance_count,omitempty"`

	// Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	MinInstanceCount *float64 `json:"minInstanceCount,omitempty" tf:"min_instance_count,omitempty"`
}

type ResourceLimitsObservation struct {

	// Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	MaxInstanceCount *float64 `json:"maxInstanceCount,omitempty" tf:"max_instance_count,omitempty"`

	// Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	MinInstanceCount *float64 `json:"minInstanceCount,omitempty" tf:"min_instance_count,omitempty"`
}

type ResourceLimitsParameters struct {

	// Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	// +kubebuilder:validation:Optional
	MaxInstanceCount *float64 `json:"maxInstanceCount,omitempty" tf:"max_instance_count,omitempty"`

	// Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
	// +kubebuilder:validation:Optional
	MinInstanceCount *float64 `json:"minInstanceCount,omitempty" tf:"min_instance_count,omitempty"`
}

type RollConfigInitParameters struct {

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`
}

type RollConfigObservation struct {

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`
}

type RollConfigParameters struct {

	// Sets the percentage of the instances to deploy in each batch.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`
}

type SchedulingTaskInitParameters struct {

	// A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Describes whether the task is enabled. When true, the task runs. When false, it does not run.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The config of this scheduled task. Depends on the value of taskType.
	TaskHeadroom []TaskHeadroomInitParameters `json:"taskHeadroom,omitempty" tf:"task_headroom,omitempty"`

	// The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type SchedulingTaskObservation struct {

	// A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Describes whether the task is enabled. When true, the task runs. When false, it does not run.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The config of this scheduled task. Depends on the value of taskType.
	TaskHeadroom []TaskHeadroomObservation `json:"taskHeadroom,omitempty" tf:"task_headroom,omitempty"`

	// The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type SchedulingTaskParameters struct {

	// A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
	// +kubebuilder:validation:Optional
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// Describes whether the task is enabled. When true, the task runs. When false, it does not run.
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// The config of this scheduled task. Depends on the value of taskType.
	// +kubebuilder:validation:Optional
	TaskHeadroom []TaskHeadroomParameters `json:"taskHeadroom,omitempty" tf:"task_headroom,omitempty"`

	// The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
	// +kubebuilder:validation:Optional
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type ShieldedInstanceConfigInitParameters struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type ShieldedInstanceConfigObservation struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type ShieldedInstanceConfigParameters struct {

	// Boolean. Enable the integrity monitoring parameter on the GCP instances.
	// +kubebuilder:validation:Optional
	EnableIntegrityMonitoring *bool `json:"enableIntegrityMonitoring,omitempty" tf:"enable_integrity_monitoring,omitempty"`

	// Boolean. Enable the secure boot parameter on the GCP instances.
	// +kubebuilder:validation:Optional
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty" tf:"enable_secure_boot,omitempty"`
}

type StorageInitParameters struct {

	// Defines the number of local SSDs to be attached per node for this VNG.
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`
}

type StorageObservation struct {

	// Defines the number of local SSDs to be attached per node for this VNG.
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`
}

type StorageParameters struct {

	// Defines the number of local SSDs to be attached per node for this VNG.
	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`
}

type StrategyInitParameters struct {

	// Defines the desired preemptible percentage for this launch specification.
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Valid Values: "cost", "availability", "balanced". Set this value to control the approach that Ocean takes when launching nodes.
	ScalingOrientation *string `json:"scalingOrientation,omitempty" tf:"scaling_orientation,omitempty"`
}

type StrategyObservation struct {

	// Defines the desired preemptible percentage for this launch specification.
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Valid Values: "cost", "availability", "balanced". Set this value to control the approach that Ocean takes when launching nodes.
	ScalingOrientation *string `json:"scalingOrientation,omitempty" tf:"scaling_orientation,omitempty"`
}

type StrategyParameters struct {

	// Defines the desired preemptible percentage for this launch specification.
	// +kubebuilder:validation:Optional
	PreemptiblePercentage *float64 `json:"preemptiblePercentage,omitempty" tf:"preemptible_percentage,omitempty"`

	// Valid Values: "cost", "availability", "balanced". Set this value to control the approach that Ocean takes when launching nodes.
	// +kubebuilder:validation:Optional
	ScalingOrientation *string `json:"scalingOrientation,omitempty" tf:"scaling_orientation,omitempty"`
}

type TaintsInitParameters struct {

	// The effect of the taint. Valid values: "NoSchedule", "PreferNoSchedule", "NoExecute".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsObservation struct {

	// The effect of the taint. Valid values: "NoSchedule", "PreferNoSchedule", "NoExecute".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The metadata key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// The effect of the taint. Valid values: "NoSchedule", "PreferNoSchedule", "NoExecute".
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The metadata key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The metadata value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaskHeadroomInitParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type TaskHeadroomObservation struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type TaskHeadroomParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits" tf:"num_of_units,omitempty"`
}

type UpdatePolicyInitParameters struct {

	// Holds the roll configuration.
	RollConfig []RollConfigInitParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyObservation struct {

	// Holds the roll configuration.
	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// Holds the roll configuration.
	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	// +kubebuilder:validation:Optional
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// OceanGkeVngSpec defines the desired state of OceanGkeVng
type OceanGkeVngSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanGkeVngParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OceanGkeVngInitParameters `json:"initProvider,omitempty"`
}

// OceanGkeVngStatus defines the observed state of OceanGkeVng.
type OceanGkeVngStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanGkeVngObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OceanGkeVng is the Schema for the OceanGkeVngs API. Provides a Spotinst Ocean Launch Spec resource using GKE.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type OceanGkeVng struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.oceanId) || (has(self.initProvider) && has(self.initProvider.oceanId))",message="spec.forProvider.oceanId is a required parameter"
	Spec   OceanGkeVngSpec   `json:"spec"`
	Status OceanGkeVngStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanGkeVngList contains a list of OceanGkeVngs
type OceanGkeVngList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanGkeVng `json:"items"`
}

// Repository type metadata.
var (
	OceanGkeVng_Kind             = "OceanGkeVng"
	OceanGkeVng_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanGkeVng_Kind}.String()
	OceanGkeVng_KindAPIVersion   = OceanGkeVng_Kind + "." + CRDGroupVersion.String()
	OceanGkeVng_GroupVersionKind = CRDGroupVersion.WithKind(OceanGkeVng_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanGkeVng{}, &OceanGkeVngList{})
}
