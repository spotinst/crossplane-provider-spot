// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FiltersInitParameters struct {

	// In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
	AcceleratedNetworking *string `json:"acceleratedNetworking,omitempty" tf:"accelerated_networking,omitempty"`

	// The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered vm sizes will support at least one of the classes from this list.
	DiskPerformance *string `json:"diskPerformance,omitempty" tf:"disk_performance,omitempty"`

	// Vm sizes belonging to a series from the list will not be available for scaling.
	// +listType=set
	ExcludeSeries []*string `json:"excludeSeries,omitempty" tf:"exclude_series,omitempty"`

	// The filtered gpu types will belong to one of the gpu types from this list.
	// +listType=set
	GpuTypes []*string `json:"gpuTypes,omitempty" tf:"gpu_types,omitempty"`

	// Maximum number of GPUs available.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of data disks available.
	MinDisk *float64 `json:"minDisk,omitempty" tf:"min_disk,omitempty"`

	// Minimum number of GPUs available.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of network interfaces.
	MinNics *float64 `json:"minNics,omitempty" tf:"min_nics,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// Vm sizes belonging to a series from the list will be available for scaling.
	// +listType=set
	Series []*string `json:"series,omitempty" tf:"series,omitempty"`

	// The filtered vm types will belong to one of the vm types from this list.
	// +listType=set
	VMTypes []*string `json:"vmTypes,omitempty" tf:"vm_types,omitempty"`
}

type FiltersObservation struct {

	// In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
	AcceleratedNetworking *string `json:"acceleratedNetworking,omitempty" tf:"accelerated_networking,omitempty"`

	// The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered vm sizes will support at least one of the classes from this list.
	DiskPerformance *string `json:"diskPerformance,omitempty" tf:"disk_performance,omitempty"`

	// Vm sizes belonging to a series from the list will not be available for scaling.
	// +listType=set
	ExcludeSeries []*string `json:"excludeSeries,omitempty" tf:"exclude_series,omitempty"`

	// The filtered gpu types will belong to one of the gpu types from this list.
	// +listType=set
	GpuTypes []*string `json:"gpuTypes,omitempty" tf:"gpu_types,omitempty"`

	// Maximum number of GPUs available.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of data disks available.
	MinDisk *float64 `json:"minDisk,omitempty" tf:"min_disk,omitempty"`

	// Minimum number of GPUs available.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of network interfaces.
	MinNics *float64 `json:"minNics,omitempty" tf:"min_nics,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// Vm sizes belonging to a series from the list will be available for scaling.
	// +listType=set
	Series []*string `json:"series,omitempty" tf:"series,omitempty"`

	// The filtered vm types will belong to one of the vm types from this list.
	// +listType=set
	VMTypes []*string `json:"vmTypes,omitempty" tf:"vm_types,omitempty"`
}

type FiltersParameters struct {

	// In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
	// +kubebuilder:validation:Optional
	AcceleratedNetworking *string `json:"acceleratedNetworking,omitempty" tf:"accelerated_networking,omitempty"`

	// The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
	// +kubebuilder:validation:Optional
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered vm sizes will support at least one of the classes from this list.
	// +kubebuilder:validation:Optional
	DiskPerformance *string `json:"diskPerformance,omitempty" tf:"disk_performance,omitempty"`

	// Vm sizes belonging to a series from the list will not be available for scaling.
	// +kubebuilder:validation:Optional
	// +listType=set
	ExcludeSeries []*string `json:"excludeSeries,omitempty" tf:"exclude_series,omitempty"`

	// The filtered gpu types will belong to one of the gpu types from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	GpuTypes []*string `json:"gpuTypes,omitempty" tf:"gpu_types,omitempty"`

	// Maximum number of GPUs available.
	// +kubebuilder:validation:Optional
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of data disks available.
	// +kubebuilder:validation:Optional
	MinDisk *float64 `json:"minDisk,omitempty" tf:"min_disk,omitempty"`

	// Minimum number of GPUs available.
	// +kubebuilder:validation:Optional
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of network interfaces.
	// +kubebuilder:validation:Optional
	MinNics *float64 `json:"minNics,omitempty" tf:"min_nics,omitempty"`

	// Minimum number of vcpus available.
	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// Vm sizes belonging to a series from the list will be available for scaling.
	// +kubebuilder:validation:Optional
	// +listType=set
	Series []*string `json:"series,omitempty" tf:"series,omitempty"`

	// The filtered vm types will belong to one of the vm types from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	VMTypes []*string `json:"vmTypes,omitempty" tf:"vm_types,omitempty"`
}

type HeadroomsInitParameters struct {

	// Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Amount of GPU to allocate for headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Configure the amount of memory (MiB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type HeadroomsObservation struct {

	// Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Amount of GPU to allocate for headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Configure the amount of memory (MiB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type HeadroomsParameters struct {

	// Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Amount of GPU to allocate for headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Configure the amount of memory (MiB) to allocate the headroom.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type LinuxOsConfigInitParameters struct {

	// System Controls
	Sysctls []SysctlsInitParameters `json:"sysctls,omitempty" tf:"sysctls,omitempty"`
}

type LinuxOsConfigObservation struct {

	// System Controls
	Sysctls []SysctlsObservation `json:"sysctls,omitempty" tf:"sysctls,omitempty"`
}

type LinuxOsConfigParameters struct {

	// System Controls
	// +kubebuilder:validation:Optional
	Sysctls []SysctlsParameters `json:"sysctls,omitempty" tf:"sysctls,omitempty"`
}

type OceanAksVngInitParameters struct {

	// An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Enable node public IP.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// Filters for the VM sizes that can be launched from the virtual node group.
	Filters []FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// Specify the custom headroom per VNG. Provide a list of headroom objects.
	Headrooms []HeadroomsInitParameters `json:"headrooms,omitempty" tf:"headrooms,omitempty"`

	// The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// An array of labels to add to the virtual node group.Only custom user labels are allowed, and not Kubernetes built-in labels or Spot internal labels.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Custom Linux OS configuration.
	LinuxOsConfig []LinuxOsConfigInitParameters `json:"linuxOsConfig,omitempty" tf:"linux_os_config,omitempty"`

	// Maximum node count limit.
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The maximum number of pods per node in the node pools.
	MaxPodsPerNode *float64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`

	// Minimum node count limit.
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// Enter a name for the virtual node group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The Ocean cluster identifier. Required for Launch Spec creation.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The size of the OS disk in GB.
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The type of the OS disk.
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// The OS SKU of the OS type. Must correlate with the os type.
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// The OS type of the OS disk. Can't be modified once set.
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
	PodSubnetIds []*string `json:"podSubnetIds,omitempty" tf:"pod_subnet_ids,omitempty"`

	// Percentage of spot VMs to maintain.
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Add taints to a virtual node group.
	Taints []TaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	UpdatePolicy []UpdatePolicyInitParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
	VnetSubnetIds []*string `json:"vnetSubnetIds,omitempty" tf:"vnet_subnet_ids,omitempty"`
}

type OceanAksVngObservation struct {

	// An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Enable node public IP.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// Filters for the VM sizes that can be launched from the virtual node group.
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// Specify the custom headroom per VNG. Provide a list of headroom objects.
	Headrooms []HeadroomsObservation `json:"headrooms,omitempty" tf:"headrooms,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// An array of labels to add to the virtual node group.Only custom user labels are allowed, and not Kubernetes built-in labels or Spot internal labels.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Custom Linux OS configuration.
	LinuxOsConfig []LinuxOsConfigObservation `json:"linuxOsConfig,omitempty" tf:"linux_os_config,omitempty"`

	// Maximum node count limit.
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The maximum number of pods per node in the node pools.
	MaxPodsPerNode *float64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`

	// Minimum node count limit.
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// Enter a name for the virtual node group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The Ocean cluster identifier. Required for Launch Spec creation.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The size of the OS disk in GB.
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The type of the OS disk.
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// The OS SKU of the OS type. Must correlate with the os type.
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// The OS type of the OS disk. Can't be modified once set.
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
	PodSubnetIds []*string `json:"podSubnetIds,omitempty" tf:"pod_subnet_ids,omitempty"`

	// Percentage of spot VMs to maintain.
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Add taints to a virtual node group.
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
	VnetSubnetIds []*string `json:"vnetSubnetIds,omitempty" tf:"vnet_subnet_ids,omitempty"`
}

type OceanAksVngParameters struct {

	// An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Enable node public IP.
	// +kubebuilder:validation:Optional
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// Filters for the VM sizes that can be launched from the virtual node group.
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// Specify the custom headroom per VNG. Provide a list of headroom objects.
	// +kubebuilder:validation:Optional
	Headrooms []HeadroomsParameters `json:"headrooms,omitempty" tf:"headrooms,omitempty"`

	// The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// An array of labels to add to the virtual node group.Only custom user labels are allowed, and not Kubernetes built-in labels or Spot internal labels.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Custom Linux OS configuration.
	// +kubebuilder:validation:Optional
	LinuxOsConfig []LinuxOsConfigParameters `json:"linuxOsConfig,omitempty" tf:"linux_os_config,omitempty"`

	// Maximum node count limit.
	// +kubebuilder:validation:Optional
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The maximum number of pods per node in the node pools.
	// +kubebuilder:validation:Optional
	MaxPodsPerNode *float64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`

	// Minimum node count limit.
	// +kubebuilder:validation:Optional
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// Enter a name for the virtual node group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The Ocean cluster identifier. Required for Launch Spec creation.
	// +kubebuilder:validation:Optional
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The size of the OS disk in GB.
	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The type of the OS disk.
	// +kubebuilder:validation:Optional
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// The OS SKU of the OS type. Must correlate with the os type.
	// +kubebuilder:validation:Optional
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// The OS type of the OS disk. Can't be modified once set.
	// +kubebuilder:validation:Optional
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
	// +kubebuilder:validation:Optional
	PodSubnetIds []*string `json:"podSubnetIds,omitempty" tf:"pod_subnet_ids,omitempty"`

	// Percentage of spot VMs to maintain.
	// +kubebuilder:validation:Optional
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Add taints to a virtual node group.
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
	// +kubebuilder:validation:Optional
	VnetSubnetIds []*string `json:"vnetSubnetIds,omitempty" tf:"vnet_subnet_ids,omitempty"`
}

type RollConfigInitParameters struct {

	// Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars and optional.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
	NodePoolNames []*string `json:"nodePoolNames,omitempty" tf:"node_pool_names,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`

	// During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
	RespectRestrictScaleDown *bool `json:"respectRestrictScaleDown,omitempty" tf:"respect_restrict_scale_down,omitempty"`

	// List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
	VngIds []*string `json:"vngIds,omitempty" tf:"vng_ids,omitempty"`
}

type RollConfigObservation struct {

	// Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars and optional.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
	NodePoolNames []*string `json:"nodePoolNames,omitempty" tf:"node_pool_names,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`

	// During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
	RespectRestrictScaleDown *bool `json:"respectRestrictScaleDown,omitempty" tf:"respect_restrict_scale_down,omitempty"`

	// List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
	VngIds []*string `json:"vngIds,omitempty" tf:"vng_ids,omitempty"`
}

type RollConfigParameters struct {

	// Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars and optional.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
	// +kubebuilder:validation:Optional
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
	// +kubebuilder:validation:Optional
	NodePoolNames []*string `json:"nodePoolNames,omitempty" tf:"node_pool_names,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`

	// During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
	// +kubebuilder:validation:Optional
	RespectRestrictScaleDown *bool `json:"respectRestrictScaleDown,omitempty" tf:"respect_restrict_scale_down,omitempty"`

	// List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
	// +kubebuilder:validation:Optional
	VngIds []*string `json:"vngIds,omitempty" tf:"vng_ids,omitempty"`
}

type SysctlsInitParameters struct {

	// Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
	VMMaxMapCount *float64 `json:"vmMaxMapCount,omitempty" tf:"vm_max_map_count,omitempty"`
}

type SysctlsObservation struct {

	// Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
	VMMaxMapCount *float64 `json:"vmMaxMapCount,omitempty" tf:"vm_max_map_count,omitempty"`
}

type SysctlsParameters struct {

	// Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
	// +kubebuilder:validation:Optional
	VMMaxMapCount *float64 `json:"vmMaxMapCount,omitempty" tf:"vm_max_map_count,omitempty"`
}

type TaintsInitParameters struct {

	// Set taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// Set label key. The following are not allowed: ["kubernetes.azure.com/agentpool", "kubernetes.io/arch", "kubernetes.io/os", "node.kubernetes.io/instance-type", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "kubernetes.azure.com/cluster", "kubernetes.azure.com/mode", "kubernetes.azure.com/role", "kubernetes.azure.com/scalesetpriority", "kubernetes.io/hostname", "kubernetes.azure.com/storageprofile", "kubernetes.azure.com/storagetier", "kubernetes.azure.com/instance-sku", "kubernetes.azure.com/node-image-version", "kubernetes.azure.com/subnet", "kubernetes.azure.com/vnet", "kubernetes.azure.com/ppg", "kubernetes.azure.com/encrypted-set", "kubernetes.azure.com/accelerator", "kubernetes.azure.com/fips_enabled", "kubernetes.azure.com/os-sku"]
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Set label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsObservation struct {

	// Set taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// Set label key. The following are not allowed: ["kubernetes.azure.com/agentpool", "kubernetes.io/arch", "kubernetes.io/os", "node.kubernetes.io/instance-type", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "kubernetes.azure.com/cluster", "kubernetes.azure.com/mode", "kubernetes.azure.com/role", "kubernetes.azure.com/scalesetpriority", "kubernetes.io/hostname", "kubernetes.azure.com/storageprofile", "kubernetes.azure.com/storagetier", "kubernetes.azure.com/instance-sku", "kubernetes.azure.com/node-image-version", "kubernetes.azure.com/subnet", "kubernetes.azure.com/vnet", "kubernetes.azure.com/ppg", "kubernetes.azure.com/encrypted-set", "kubernetes.azure.com/accelerator", "kubernetes.azure.com/fips_enabled", "kubernetes.azure.com/os-sku"]
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Set label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// Set taint effect.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// Set label key. The following are not allowed: ["kubernetes.azure.com/agentpool", "kubernetes.io/arch", "kubernetes.io/os", "node.kubernetes.io/instance-type", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "kubernetes.azure.com/cluster", "kubernetes.azure.com/mode", "kubernetes.azure.com/role", "kubernetes.azure.com/scalesetpriority", "kubernetes.io/hostname", "kubernetes.azure.com/storageprofile", "kubernetes.azure.com/storagetier", "kubernetes.azure.com/instance-sku", "kubernetes.azure.com/node-image-version", "kubernetes.azure.com/subnet", "kubernetes.azure.com/vnet", "kubernetes.azure.com/ppg", "kubernetes.azure.com/encrypted-set", "kubernetes.azure.com/accelerator", "kubernetes.azure.com/fips_enabled", "kubernetes.azure.com/os-sku"]
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// Set label value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type UpdatePolicyInitParameters struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	RollConfig []RollConfigInitParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// If set to true along with the vng update, roll will be triggered.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyObservation struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// If set to true along with the vng update, roll will be triggered.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// If set to true along with the vng update, roll will be triggered.
	// +kubebuilder:validation:Optional
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// OceanAksVngSpec defines the desired state of OceanAksVng
type OceanAksVngSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanAksVngParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OceanAksVngInitParameters `json:"initProvider,omitempty"`
}

// OceanAksVngStatus defines the observed state of OceanAksVng.
type OceanAksVngStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanAksVngObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OceanAksVng is the Schema for the OceanAksVngs API. Provides a Spotinst Ocean Virtual Node Group resource using AKS.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,crossplane-provider-spot}
type OceanAksVng struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.oceanId) || (has(self.initProvider) && has(self.initProvider.oceanId))",message="spec.forProvider.oceanId is a required parameter"
	Spec   OceanAksVngSpec   `json:"spec"`
	Status OceanAksVngStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAksVngList contains a list of OceanAksVngs
type OceanAksVngList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanAksVng `json:"items"`
}

// Repository type metadata.
var (
	OceanAksVng_Kind             = "OceanAksVng"
	OceanAksVng_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanAksVng_Kind}.String()
	OceanAksVng_KindAPIVersion   = OceanAksVng_Kind + "." + CRDGroupVersion.String()
	OceanAksVng_GroupVersionKind = CRDGroupVersion.WithKind(OceanAksVng_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanAksVng{}, &OceanAksVngList{})
}
