/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FiltersObservation struct {

	// In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
	AcceleratedNetworking *string `json:"acceleratedNetworking,omitempty" tf:"accelerated_networking,omitempty"`

	// The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered vm sizes will support at least one of the classes from this list.
	DiskPerformance *string `json:"diskPerformance,omitempty" tf:"disk_performance,omitempty"`

	// Vm sizes belonging to a series from the list will not be available for scaling.
	ExcludeSeries []*string `json:"excludeSeries,omitempty" tf:"exclude_series,omitempty"`

	// Maximum number of GPUs available.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of data disks available.
	MinData *float64 `json:"minData,omitempty" tf:"min_data,omitempty"`

	// Minimum number of GPUs available.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of network interfaces.
	MinNics *float64 `json:"minNics,omitempty" tf:"min_nics,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// Vm sizes belonging to a series from the list will be available for scaling.
	Series []*string `json:"series,omitempty" tf:"series,omitempty"`

	// The filtered vm types will belong to one of the vm types from this list.
	VMTypes []*string `json:"vmTypes,omitempty" tf:"vm_types,omitempty"`
}

type FiltersParameters struct {

	// In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
	// +kubebuilder:validation:Optional
	AcceleratedNetworking *string `json:"acceleratedNetworking,omitempty" tf:"accelerated_networking,omitempty"`

	// The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
	// +kubebuilder:validation:Optional
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered vm sizes will support at least one of the classes from this list.
	// +kubebuilder:validation:Optional
	DiskPerformance *string `json:"diskPerformance,omitempty" tf:"disk_performance,omitempty"`

	// Vm sizes belonging to a series from the list will not be available for scaling.
	// +kubebuilder:validation:Optional
	ExcludeSeries []*string `json:"excludeSeries,omitempty" tf:"exclude_series,omitempty"`

	// Maximum number of GPUs available.
	// +kubebuilder:validation:Optional
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of data disks available.
	// +kubebuilder:validation:Optional
	MinData *float64 `json:"minData,omitempty" tf:"min_data,omitempty"`

	// Minimum number of GPUs available.
	// +kubebuilder:validation:Optional
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum number of network interfaces.
	// +kubebuilder:validation:Optional
	MinNics *float64 `json:"minNics,omitempty" tf:"min_nics,omitempty"`

	// Minimum number of vcpus available.
	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// Vm sizes belonging to a series from the list will be available for scaling.
	// +kubebuilder:validation:Optional
	Series []*string `json:"series,omitempty" tf:"series,omitempty"`

	// The filtered vm types will belong to one of the vm types from this list.
	// +kubebuilder:validation:Optional
	VMTypes []*string `json:"vmTypes,omitempty" tf:"vm_types,omitempty"`
}

type HeadroomsObservation struct {

	// Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Amount of GPU to allocate for headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Configure the amount of memory (MiB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type HeadroomsParameters struct {

	// Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Amount of GPU to allocate for headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Configure the amount of memory (MiB) to allocate the headroom.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type OceanAksVngObservation struct {

	// An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Enable node public IP.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// Filters for the VM sizes that can be launched from the virtual node group.
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// Specify the custom headroom per VNG. Provide a list of headroom objects.
	Headrooms []HeadroomsObservation `json:"headrooms,omitempty" tf:"headrooms,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// An array of labels to add to the virtual node group.Only custom user labels are allowed, and not Kubernetes built-in labels or Spot internal labels.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Maximum node count limit.
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The maximum number of pods per node in the node pools.
	MaxPodsPerNode *float64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`

	// Minimum node count limit.
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// Enter a name for the virtual node group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The Ocean cluster identifier. Required for Launch Spec creation.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The size of the OS disk in GB.
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The type of the OS disk.
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// The OS SKU of the OS type. Must correlate with the os type.
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// The OS type of the OS disk. Can't be modified once set.
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
	PodSubnetIds []*string `json:"podSubnetIds,omitempty" tf:"pod_subnet_ids,omitempty"`

	// Percentage of spot VMs to maintain.
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Add taints to a virtual node group.
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
	VnetSubnetIds []*string `json:"vnetSubnetIds,omitempty" tf:"vnet_subnet_ids,omitempty"`
}

type OceanAksVngParameters struct {

	// An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Enable node public IP.
	// +kubebuilder:validation:Optional
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// Filters for the VM sizes that can be launched from the virtual node group.
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// Specify the custom headroom per VNG. Provide a list of headroom objects.
	// +kubebuilder:validation:Optional
	Headrooms []HeadroomsParameters `json:"headrooms,omitempty" tf:"headrooms,omitempty"`

	// The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// An array of labels to add to the virtual node group.Only custom user labels are allowed, and not Kubernetes built-in labels or Spot internal labels.
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Maximum node count limit.
	// +kubebuilder:validation:Optional
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The maximum number of pods per node in the node pools.
	// +kubebuilder:validation:Optional
	MaxPodsPerNode *float64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`

	// Minimum node count limit.
	// +kubebuilder:validation:Optional
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// Enter a name for the virtual node group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The Ocean cluster identifier. Required for Launch Spec creation.
	// +kubebuilder:validation:Optional
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// The size of the OS disk in GB.
	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The type of the OS disk.
	// +kubebuilder:validation:Optional
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// The OS SKU of the OS type. Must correlate with the os type.
	// +kubebuilder:validation:Optional
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// The OS type of the OS disk. Can't be modified once set.
	// +kubebuilder:validation:Optional
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
	// +kubebuilder:validation:Optional
	PodSubnetIds []*string `json:"podSubnetIds,omitempty" tf:"pod_subnet_ids,omitempty"`

	// Percentage of spot VMs to maintain.
	// +kubebuilder:validation:Optional
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Add taints to a virtual node group.
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
	// +kubebuilder:validation:Optional
	VnetSubnetIds []*string `json:"vnetSubnetIds,omitempty" tf:"vnet_subnet_ids,omitempty"`
}

type TaintsObservation struct {

	// Set taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// Set label key. The following are not allowed: ["kubernetes.azure.com/agentpool", "kubernetes.io/arch", "kubernetes.io/os", "node.kubernetes.io/instance-type", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "kubernetes.azure.com/cluster", "kubernetes.azure.com/mode", "kubernetes.azure.com/role", "kubernetes.azure.com/scalesetpriority", "kubernetes.io/hostname", "kubernetes.azure.com/storageprofile", "kubernetes.azure.com/storagetier", "kubernetes.azure.com/instance-sku", "kubernetes.azure.com/node-image-version", "kubernetes.azure.com/subnet", "kubernetes.azure.com/vnet", "kubernetes.azure.com/ppg", "kubernetes.azure.com/encrypted-set", "kubernetes.azure.com/accelerator", "kubernetes.azure.com/fips_enabled", "kubernetes.azure.com/os-sku"]
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Set label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// Set taint effect.
	// +kubebuilder:validation:Required
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// Set label key. The following are not allowed: ["kubernetes.azure.com/agentpool", "kubernetes.io/arch", "kubernetes.io/os", "node.kubernetes.io/instance-type", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "kubernetes.azure.com/cluster", "kubernetes.azure.com/mode", "kubernetes.azure.com/role", "kubernetes.azure.com/scalesetpriority", "kubernetes.io/hostname", "kubernetes.azure.com/storageprofile", "kubernetes.azure.com/storagetier", "kubernetes.azure.com/instance-sku", "kubernetes.azure.com/node-image-version", "kubernetes.azure.com/subnet", "kubernetes.azure.com/vnet", "kubernetes.azure.com/ppg", "kubernetes.azure.com/encrypted-set", "kubernetes.azure.com/accelerator", "kubernetes.azure.com/fips_enabled", "kubernetes.azure.com/os-sku"]
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Set label value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// OceanAksVngSpec defines the desired state of OceanAksVng
type OceanAksVngSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanAksVngParameters `json:"forProvider"`
}

// OceanAksVngStatus defines the observed state of OceanAksVng.
type OceanAksVngStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanAksVngObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAksVng is the Schema for the OceanAksVngs API. Provides a Spotinst Ocean Virtual Node Group resource using AKS.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type OceanAksVng struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.oceanId)",message="oceanId is a required parameter"
	Spec   OceanAksVngSpec   `json:"spec"`
	Status OceanAksVngStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAksVngList contains a list of OceanAksVngs
type OceanAksVngList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanAksVng `json:"items"`
}

// Repository type metadata.
var (
	OceanAksVng_Kind             = "OceanAksVng"
	OceanAksVng_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanAksVng_Kind}.String()
	OceanAksVng_KindAPIVersion   = OceanAksVng_Kind + "." + CRDGroupVersion.String()
	OceanAksVng_GroupVersionKind = CRDGroupVersion.WithKind(OceanAksVng_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanAksVng{}, &OceanAksVngList{})
}
