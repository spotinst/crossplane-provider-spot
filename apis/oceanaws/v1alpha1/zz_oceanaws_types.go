// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AMIAutoUpdateClusterRollInitParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type AMIAutoUpdateClusterRollObservation struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type AMIAutoUpdateClusterRollParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type AMIAutoUpdateInitParameters struct {

	// Set clusterRoll object
	AMIAutoUpdateClusterRoll []AMIAutoUpdateClusterRollInitParameters `json:"amiAutoUpdateClusterRoll,omitempty" tf:"ami_auto_update_cluster_roll,omitempty"`

	// When the AMI is updated according to the configuration set, a cluster roll can be triggered
	ApplyRoll *bool `json:"applyRoll,omitempty" tf:"apply_roll,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
	MinorVersion *bool `json:"minorVersion,omitempty" tf:"minor_version,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ images with the latest security patches. either "patch" or "minorVersion" must be true.
	Patch *bool `json:"patch,omitempty" tf:"patch,omitempty"`
}

type AMIAutoUpdateObservation struct {

	// Set clusterRoll object
	AMIAutoUpdateClusterRoll []AMIAutoUpdateClusterRollObservation `json:"amiAutoUpdateClusterRoll,omitempty" tf:"ami_auto_update_cluster_roll,omitempty"`

	// When the AMI is updated according to the configuration set, a cluster roll can be triggered
	ApplyRoll *bool `json:"applyRoll,omitempty" tf:"apply_roll,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
	MinorVersion *bool `json:"minorVersion,omitempty" tf:"minor_version,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ images with the latest security patches. either "patch" or "minorVersion" must be true.
	Patch *bool `json:"patch,omitempty" tf:"patch,omitempty"`
}

type AMIAutoUpdateParameters struct {

	// Set clusterRoll object
	// +kubebuilder:validation:Optional
	AMIAutoUpdateClusterRoll []AMIAutoUpdateClusterRollParameters `json:"amiAutoUpdateClusterRoll,omitempty" tf:"ami_auto_update_cluster_roll,omitempty"`

	// When the AMI is updated according to the configuration set, a cluster roll can be triggered
	// +kubebuilder:validation:Optional
	ApplyRoll *bool `json:"applyRoll,omitempty" tf:"apply_roll,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
	// +kubebuilder:validation:Optional
	MinorVersion *bool `json:"minorVersion,omitempty" tf:"minor_version,omitempty"`

	// When set to 'true', the auto-update process will update the VNGs’ images with the latest security patches. either "patch" or "minorVersion" must be true.
	// +kubebuilder:validation:Optional
	Patch *bool `json:"patch,omitempty" tf:"patch,omitempty"`
}

type AttachLoadBalancerInitParameters struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AttachLoadBalancerObservation struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AttachLoadBalancerParameters struct {

	// Required if type is set to TARGET_GROUP
	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type AutoscaleDownInitParameters struct {
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleDownObservation struct {
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// When set to 'true', the Aggressive Scale Down feature is enabled.
	// +kubebuilder:validation:Optional
	IsAggressiveScaleDownEnabled *bool `json:"isAggressiveScaleDownEnabled,omitempty" tf:"is_aggressive_scale_down_enabled,omitempty"`

	// Would represent the maximum % to scale-down. Number between 1-100.
	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleHeadroomInitParameters struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUs to allocate the headroom.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomObservation struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUs to allocate the headroom.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MB) to allocate the headroom.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomParameters struct {

	// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUs to allocate the headroom.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MB) to allocate the headroom.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscalerInitParameters struct {

	// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when autoscale_is_auto_config toggled on.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	AutoscaleCooldown *float64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// Auto Scaling scale down operations.
	AutoscaleDown []AutoscaleDownInitParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	AutoscaleHeadroom []AutoscaleHeadroomInitParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// Enable the Ocean Kubernetes Auto Scaler.
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// List of Ocean extended resource definitions to use in this cluster.
	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	ResourceLimits []ResourceLimitsInitParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AutoscalerObservation struct {

	// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when autoscale_is_auto_config toggled on.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	AutoscaleCooldown *float64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// Auto Scaling scale down operations.
	AutoscaleDown []AutoscaleDownObservation `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	AutoscaleHeadroom []AutoscaleHeadroomObservation `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// Enable the Ocean Kubernetes Auto Scaler.
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// List of Ocean extended resource definitions to use in this cluster.
	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	ResourceLimits []ResourceLimitsObservation `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AutoscalerParameters struct {

	// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when autoscale_is_auto_config toggled on.
	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// Cooldown period between scaling actions.
	// +kubebuilder:validation:Optional
	AutoscaleCooldown *float64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// Auto Scaling scale down operations.
	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []AutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// Automatically configure and optimize headroom resources.
	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// Enable the Ocean Kubernetes Auto Scaler.
	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
	// +kubebuilder:validation:Optional
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// List of Ocean extended resource definitions to use in this cluster.
	// +kubebuilder:validation:Optional
	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	// Optionally set upper and lower bounds on the resource usage of the cluster.
	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type BlockDeviceMappingsInitParameters struct {

	// String. Set device name. (Example: /dev/xvda).
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Object. Set Elastic Block Store properties .
	EBS []EBSInitParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type BlockDeviceMappingsObservation struct {

	// String. Set device name. (Example: /dev/xvda).
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Object. Set Elastic Block Store properties .
	EBS []EBSObservation `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type BlockDeviceMappingsParameters struct {

	// String. Set device name. (Example: /dev/xvda).
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Object. Set Elastic Block Store properties .
	// +kubebuilder:validation:Optional
	EBS []EBSParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type ClusterOrientationInitParameters struct {

	// You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: costOriented,balanced,cheapest.
	AvailabilityVsCost *string `json:"availabilityVsCost,omitempty" tf:"availability_vs_cost,omitempty"`
}

type ClusterOrientationObservation struct {

	// You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: costOriented,balanced,cheapest.
	AvailabilityVsCost *string `json:"availabilityVsCost,omitempty" tf:"availability_vs_cost,omitempty"`
}

type ClusterOrientationParameters struct {

	// You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: costOriented,balanced,cheapest.
	// +kubebuilder:validation:Optional
	AvailabilityVsCost *string `json:"availabilityVsCost,omitempty" tf:"availability_vs_cost,omitempty"`
}

type DetachLoadBalancerInitParameters struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DetachLoadBalancerObservation struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DetachLoadBalancerParameters struct {

	// Required if type is set to TARGET_GROUP
	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type DynamicIopsInitParameters struct {

	// Int. Initial size for volume. (Example: 50)
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicIopsObservation struct {

	// Int. Initial size for volume. (Example: 50)
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicIopsParameters struct {

	// Int. Initial size for volume. (Example: 50)
	// +kubebuilder:validation:Optional
	BaseSize *float64 `json:"baseSize" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	// +kubebuilder:validation:Optional
	Resource *string `json:"resource" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	// +kubebuilder:validation:Optional
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit" tf:"size_per_resource_unit,omitempty"`
}

type DynamicVolumeSizeInitParameters struct {

	// Int. Initial size for volume. (Example: 50)
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicVolumeSizeObservation struct {

	// Int. Initial size for volume. (Example: 50)
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicVolumeSizeParameters struct {

	// Int. Initial size for volume. (Example: 50)
	// +kubebuilder:validation:Optional
	BaseSize *float64 `json:"baseSize" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	// +kubebuilder:validation:Optional
	Resource *string `json:"resource" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB).
	// +kubebuilder:validation:Optional
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit" tf:"size_per_resource_unit,omitempty"`
}

type EBSInitParameters struct {

	// Boolean. Flag to delete the EBS on instance termination.
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Set dynamic IOPS properties. When using this object, you cannot use the iops attribute. You must use one or the other.
	DynamicIops []DynamicIopsInitParameters `json:"dynamicIops,omitempty" tf:"dynamic_iops,omitempty"`

	// Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
	DynamicVolumeSize []DynamicVolumeSizeInitParameters `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// Boolean. Enables EBS encryption on the volume.
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// Int. The number of I/O operations per second (IOPS) that the volume supports.
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// String. The Snapshot ID to mount by.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// The amount of data transferred to or from a storage device per second, you can use this param just in a case that volume_type = gp3.
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// Int. The size, in GB of the volume.
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// String. The type of the volume. (Example: gp2).
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type EBSObservation struct {

	// Boolean. Flag to delete the EBS on instance termination.
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Set dynamic IOPS properties. When using this object, you cannot use the iops attribute. You must use one or the other.
	DynamicIops []DynamicIopsObservation `json:"dynamicIops,omitempty" tf:"dynamic_iops,omitempty"`

	// Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
	DynamicVolumeSize []DynamicVolumeSizeObservation `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// Boolean. Enables EBS encryption on the volume.
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// Int. The number of I/O operations per second (IOPS) that the volume supports.
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// String. The Snapshot ID to mount by.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// The amount of data transferred to or from a storage device per second, you can use this param just in a case that volume_type = gp3.
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// Int. The size, in GB of the volume.
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// String. The type of the volume. (Example: gp2).
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type EBSParameters struct {

	// Boolean. Flag to delete the EBS on instance termination.
	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Set dynamic IOPS properties. When using this object, you cannot use the iops attribute. You must use one or the other.
	// +kubebuilder:validation:Optional
	DynamicIops []DynamicIopsParameters `json:"dynamicIops,omitempty" tf:"dynamic_iops,omitempty"`

	// Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
	// +kubebuilder:validation:Optional
	DynamicVolumeSize []DynamicVolumeSizeParameters `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// Boolean. Enables EBS encryption on the volume.
	// +kubebuilder:validation:Optional
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// Int. The number of I/O operations per second (IOPS) that the volume supports.
	// +kubebuilder:validation:Optional
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// String. The Snapshot ID to mount by.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// The amount of data transferred to or from a storage device per second, you can use this param just in a case that volume_type = gp3.
	// +kubebuilder:validation:Optional
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// Int. The size, in GB of the volume.
	// +kubebuilder:validation:Optional
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// String. The type of the volume. (Example: gp2).
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ExportInitParameters struct {

	// Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
	S3 []S3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ExportObservation struct {

	// Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
	S3 []S3Observation `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ExportParameters struct {

	// Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
	// +kubebuilder:validation:Optional
	S3 []S3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type FiltersInitParameters struct {

	// The filtered instance types will support at least one of the architectures from this list.
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered instance types will belong to one of the categories types from this list.
	// +listType=set
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// The filtered instance types will have one of the disk type from this list.
	// +listType=set
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// In case excludeMetal is set to true, metal types will not be available for scaling.
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// The filtered instance types will have a hypervisor type from this list.
	// +listType=set
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Ena is supported or not.
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// Maximum total number of GPUs.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum Bandwidth in Gib/s of network performance.
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of network interfaces (ENIs).
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// Minimum total number of GPUs.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum Bandwidth in Gib/s of network performance.
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// The filtered instance types will have a root device types from this list.
	// +listType=set
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// The filtered instance types will support at least one of the virtualization types from this list.
	// +listType=set
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type FiltersObservation struct {

	// The filtered instance types will support at least one of the architectures from this list.
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered instance types will belong to one of the categories types from this list.
	// +listType=set
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// The filtered instance types will have one of the disk type from this list.
	// +listType=set
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// In case excludeMetal is set to true, metal types will not be available for scaling.
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// The filtered instance types will have a hypervisor type from this list.
	// +listType=set
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Ena is supported or not.
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// Maximum total number of GPUs.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum Bandwidth in Gib/s of network performance.
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of network interfaces (ENIs).
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// Minimum total number of GPUs.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum Bandwidth in Gib/s of network performance.
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// The filtered instance types will have a root device types from this list.
	// +listType=set
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// The filtered instance types will support at least one of the virtualization types from this list.
	// +listType=set
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type FiltersParameters struct {

	// The filtered instance types will support at least one of the architectures from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// The filtered instance types will belong to one of the categories types from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// The filtered instance types will have one of the disk type from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	// +listType=set
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// In case excludeMetal is set to true, metal types will not be available for scaling.
	// +kubebuilder:validation:Optional
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// The filtered instance types will have a hypervisor type from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	// +listType=set
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Ena is supported or not.
	// +kubebuilder:validation:Optional
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// Maximum total number of GPUs.
	// +kubebuilder:validation:Optional
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum Bandwidth in Gib/s of network performance.
	// +kubebuilder:validation:Optional
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of network interfaces (ENIs).
	// +kubebuilder:validation:Optional
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// Minimum total number of GPUs.
	// +kubebuilder:validation:Optional
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum Bandwidth in Gib/s of network performance.
	// +kubebuilder:validation:Optional
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// Minimum number of vcpus available.
	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// The filtered instance types will have a root device types from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// The filtered instance types will support at least one of the virtualization types from this list.
	// +kubebuilder:validation:Optional
	// +listType=set
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type InstanceMetadataOptionsInitParameters struct {

	// An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// Determines if a signed token is required or not. Valid values: optional or required.
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`
}

type InstanceMetadataOptionsObservation struct {

	// An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// Determines if a signed token is required or not. Valid values: optional or required.
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`
}

type InstanceMetadataOptionsParameters struct {

	// An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// Determines if a signed token is required or not. Valid values: optional or required.
	// +kubebuilder:validation:Optional
	HTTPTokens *string `json:"httpTokens" tf:"http_tokens,omitempty"`
}

type LoadBalancersInitParameters struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoadBalancersObservation struct {

	// Required if type is set to TARGET_GROUP
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoadBalancersParameters struct {

	// Required if type is set to TARGET_GROUP
	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// The cluster name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Can be set to CLASSIC or TARGET_GROUP
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoggingInitParameters struct {

	// Logging Export configuration.
	Export []ExportInitParameters `json:"export,omitempty" tf:"export,omitempty"`
}

type LoggingObservation struct {

	// Logging Export configuration.
	Export []ExportObservation `json:"export,omitempty" tf:"export,omitempty"`
}

type LoggingParameters struct {

	// Logging Export configuration.
	// +kubebuilder:validation:Optional
	Export []ExportParameters `json:"export,omitempty" tf:"export,omitempty"`
}

type OceanAwsInitParameters struct {

	// Configure IPv6 address allocation.
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// Configure public IP address allocation.
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// Attach load balancers to the cluster.
	AttachLoadBalancer []AttachLoadBalancerInitParameters `json:"attachLoadBalancer,omitempty" tf:"attach_load_balancer,omitempty"`

	// Describes the Ocean Kubernetes Auto Scaler.
	Autoscaler []AutoscalerInitParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Instance types not allowed in the Ocean cluster. Cannot be configured if whitelist is configured.
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
	BlockDeviceMappings []BlockDeviceMappingsInitParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	ClusterOrientation []ClusterOrientationInitParameters `json:"clusterOrientation,omitempty" tf:"cluster_orientation,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// Detach load balancers from the cluster.
	DetachLoadBalancer []DetachLoadBalancerInitParameters `json:"detachLoadBalancer,omitempty" tf:"detach_load_balancer,omitempty"`

	// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	Filters []FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The amount of time, in seconds, after the instance has launched to start checking its health.
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
	HealthCheckUnhealthyDurationBeforeReplacement *float64 `json:"healthCheckUnhealthyDurationBeforeReplacement,omitempty" tf:"health_check_unhealthy_duration_before_replacement,omitempty"`

	// The instance profile iam role.
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// ID of the image used to launch the instances.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// Ocean instance metadata options object for IMDSv2.
	InstanceMetadataOptions []InstanceMetadataOptionsInitParameters `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// The key pair to attach the instances.
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// - Array of load balancer objects to add to ocean cluster
	LoadBalancers []LoadBalancersInitParameters `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// Logging configuration.
	Logging []LoggingInitParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The region the cluster will run in.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Specifies the count of ENIs to reserve per instance type for scaling purposes.
	ReservedEnis *float64 `json:"reservedEnis,omitempty" tf:"reserved_enis,omitempty"`

	// Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
	ResourceTagSpecification []ResourceTagSpecificationInitParameters `json:"resourceTagSpecification,omitempty" tf:"resource_tag_specification,omitempty"`

	// The size (in Gb) to allocate for the root volume. Minimum 20.
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Set scheduling object.
	ScheduledTask []ScheduledTaskInitParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// One or more security group ids.
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// Ocean will spread the nodes across markets by this value. Possible values: vcpu or count.
	SpreadNodesBy *string `json:"spreadNodesBy,omitempty" tf:"spread_nodes_by,omitempty"`

	// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// Optionally adds tags to instances launched in an Ocean cluster.
	Tags []TagsInitParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	UpdatePolicy []UpdatePolicyInitParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	// When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Base64-encoded MIME user data to make available to the instances.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// If savings plans exist, Ocean will utilize them before launching Spot instances.
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// If Reserved instances exist, Ocean will utilize them before launching Spot instances.
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist is configured.
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type OceanAwsObservation struct {

	// Configure IPv6 address allocation.
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// Configure public IP address allocation.
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// Attach load balancers to the cluster.
	AttachLoadBalancer []AttachLoadBalancerObservation `json:"attachLoadBalancer,omitempty" tf:"attach_load_balancer,omitempty"`

	// Describes the Ocean Kubernetes Auto Scaler.
	Autoscaler []AutoscalerObservation `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Instance types not allowed in the Ocean cluster. Cannot be configured if whitelist is configured.
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
	BlockDeviceMappings []BlockDeviceMappingsObservation `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	ClusterOrientation []ClusterOrientationObservation `json:"clusterOrientation,omitempty" tf:"cluster_orientation,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// Detach load balancers from the cluster.
	DetachLoadBalancer []DetachLoadBalancerObservation `json:"detachLoadBalancer,omitempty" tf:"detach_load_balancer,omitempty"`

	// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// The amount of time, in seconds, after the instance has launched to start checking its health.
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
	HealthCheckUnhealthyDurationBeforeReplacement *float64 `json:"healthCheckUnhealthyDurationBeforeReplacement,omitempty" tf:"health_check_unhealthy_duration_before_replacement,omitempty"`

	// The instance profile iam role.
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// The identifier of The S3 data integration to export the logs to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// ID of the image used to launch the instances.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// Ocean instance metadata options object for IMDSv2.
	InstanceMetadataOptions []InstanceMetadataOptionsObservation `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// The key pair to attach the instances.
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// - Array of load balancer objects to add to ocean cluster
	LoadBalancers []LoadBalancersObservation `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// Logging configuration.
	Logging []LoggingObservation `json:"logging,omitempty" tf:"logging,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The cluster name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The region the cluster will run in.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Specifies the count of ENIs to reserve per instance type for scaling purposes.
	ReservedEnis *float64 `json:"reservedEnis,omitempty" tf:"reserved_enis,omitempty"`

	// Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
	ResourceTagSpecification []ResourceTagSpecificationObservation `json:"resourceTagSpecification,omitempty" tf:"resource_tag_specification,omitempty"`

	// The size (in Gb) to allocate for the root volume. Minimum 20.
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Set scheduling object.
	ScheduledTask []ScheduledTaskObservation `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// One or more security group ids.
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// Ocean will spread the nodes across markets by this value. Possible values: vcpu or count.
	SpreadNodesBy *string `json:"spreadNodesBy,omitempty" tf:"spread_nodes_by,omitempty"`

	// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// Optionally adds tags to instances launched in an Ocean cluster.
	Tags []TagsObservation `json:"tags,omitempty" tf:"tags,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	// When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Base64-encoded MIME user data to make available to the instances.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// If savings plans exist, Ocean will utilize them before launching Spot instances.
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// If Reserved instances exist, Ocean will utilize them before launching Spot instances.
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist is configured.
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type OceanAwsParameters struct {

	// Configure IPv6 address allocation.
	// +kubebuilder:validation:Optional
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// Configure public IP address allocation.
	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// Attach load balancers to the cluster.
	// +kubebuilder:validation:Optional
	AttachLoadBalancer []AttachLoadBalancerParameters `json:"attachLoadBalancer,omitempty" tf:"attach_load_balancer,omitempty"`

	// Describes the Ocean Kubernetes Auto Scaler.
	// +kubebuilder:validation:Optional
	Autoscaler []AutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// Instance types not allowed in the Ocean cluster. Cannot be configured if whitelist is configured.
	// +kubebuilder:validation:Optional
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterOrientation []ClusterOrientationParameters `json:"clusterOrientation,omitempty" tf:"cluster_orientation,omitempty"`

	// A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
	// +kubebuilder:validation:Optional
	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	// The number of instances to launch and maintain in the cluster.
	// +kubebuilder:validation:Optional
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// Detach load balancers from the cluster.
	// +kubebuilder:validation:Optional
	DetachLoadBalancer []DetachLoadBalancerParameters `json:"detachLoadBalancer,omitempty" tf:"detach_load_balancer,omitempty"`

	// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
	// +kubebuilder:validation:Optional
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
	// +kubebuilder:validation:Optional
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// List of filters. The Instance types that match with all filters compose the Ocean's whitelist parameter. Cannot be configured together with whitelist/blacklist.
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The amount of time, in seconds, after the instance has launched to start checking its health.
	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
	// +kubebuilder:validation:Optional
	HealthCheckUnhealthyDurationBeforeReplacement *float64 `json:"healthCheckUnhealthyDurationBeforeReplacement,omitempty" tf:"health_check_unhealthy_duration_before_replacement,omitempty"`

	// The instance profile iam role.
	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// ID of the image used to launch the instances.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// Ocean instance metadata options object for IMDSv2.
	// +kubebuilder:validation:Optional
	InstanceMetadataOptions []InstanceMetadataOptionsParameters `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// The key pair to attach the instances.
	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// - Array of load balancer objects to add to ocean cluster
	// +kubebuilder:validation:Optional
	LoadBalancers []LoadBalancersParameters `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// Logging configuration.
	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// The upper limit of instances the cluster can scale up to.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The lower limit of instances the cluster can scale down to.
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The cluster name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The region the cluster will run in.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Specifies the count of ENIs to reserve per instance type for scaling purposes.
	// +kubebuilder:validation:Optional
	ReservedEnis *float64 `json:"reservedEnis,omitempty" tf:"reserved_enis,omitempty"`

	// Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
	// +kubebuilder:validation:Optional
	ResourceTagSpecification []ResourceTagSpecificationParameters `json:"resourceTagSpecification,omitempty" tf:"resource_tag_specification,omitempty"`

	// The size (in Gb) to allocate for the root volume. Minimum 20.
	// +kubebuilder:validation:Optional
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Set scheduling object.
	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// One or more security group ids.
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
	// +kubebuilder:validation:Optional
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// Ocean will spread the nodes across markets by this value. Possible values: vcpu or count.
	// +kubebuilder:validation:Optional
	SpreadNodesBy *string `json:"spreadNodesBy,omitempty" tf:"spread_nodes_by,omitempty"`

	// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// Optionally adds tags to instances launched in an Ocean cluster.
	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// launch specification defined on the Ocean object will function only as a template for virtual node groups.
	// When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
	// +kubebuilder:validation:Optional
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// Base64-encoded MIME user data to make available to the instances.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// If savings plans exist, Ocean will utilize them before launching Spot instances.
	// +kubebuilder:validation:Optional
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// If Reserved instances exist, Ocean will utilize them before launching Spot instances.
	// +kubebuilder:validation:Optional
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// Instance types allowed in the Ocean cluster. Cannot be configured if blacklist is configured.
	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type ParametersClusterRollInitParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ParametersClusterRollObservation struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ParametersClusterRollParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// Add a comment description for the roll. The comment is limited to 256 chars
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type ParametersInitParameters struct {

	// Set amiAutoUpdate object
	AMIAutoUpdate []AMIAutoUpdateInitParameters `json:"amiAutoUpdate,omitempty" tf:"ami_auto_update,omitempty"`

	// Set clusterRoll object
	ParametersClusterRoll []ParametersClusterRollInitParameters `json:"parametersClusterRoll,omitempty" tf:"parameters_cluster_roll,omitempty"`
}

type ParametersObservation struct {

	// Set amiAutoUpdate object
	AMIAutoUpdate []AMIAutoUpdateObservation `json:"amiAutoUpdate,omitempty" tf:"ami_auto_update,omitempty"`

	// Set clusterRoll object
	ParametersClusterRoll []ParametersClusterRollObservation `json:"parametersClusterRoll,omitempty" tf:"parameters_cluster_roll,omitempty"`
}

type ParametersParameters struct {

	// Set amiAutoUpdate object
	// +kubebuilder:validation:Optional
	AMIAutoUpdate []AMIAutoUpdateParameters `json:"amiAutoUpdate,omitempty" tf:"ami_auto_update,omitempty"`

	// Set clusterRoll object
	// +kubebuilder:validation:Optional
	ParametersClusterRoll []ParametersClusterRollParameters `json:"parametersClusterRoll,omitempty" tf:"parameters_cluster_roll,omitempty"`
}

type ResourceLimitsInitParameters struct {

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceLimitsObservation struct {

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceLimitsParameters struct {

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceTagSpecificationInitParameters struct {

	// Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
	ShouldTagVolumes *bool `json:"shouldTagVolumes,omitempty" tf:"should_tag_volumes,omitempty"`
}

type ResourceTagSpecificationObservation struct {

	// Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
	ShouldTagVolumes *bool `json:"shouldTagVolumes,omitempty" tf:"should_tag_volumes,omitempty"`
}

type ResourceTagSpecificationParameters struct {

	// Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
	// +kubebuilder:validation:Optional
	ShouldTagVolumes *bool `json:"shouldTagVolumes,omitempty" tf:"should_tag_volumes,omitempty"`
}

type RollConfigInitParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// List of virtual node group identifiers to be rolled.
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type RollConfigObservation struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	// List of virtual node group identifiers to be rolled.
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type RollConfigParameters struct {

	// Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// Sets the percentage of the instances to deploy in each batch.
	// +kubebuilder:validation:Optional
	BatchSizePercentage *float64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// List of virtual node group identifiers to be rolled.
	// +kubebuilder:validation:Optional
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// During the roll, if the parameter is set to true we honor PDB during the instance replacement.
	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type S3InitParameters struct {

	// The identifier of The S3 data integration to export the logs to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type S3Observation struct {

	// The identifier of The S3 data integration to export the logs to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type S3Parameters struct {

	// The identifier of The S3 data integration to export the logs to.
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`
}

type ScheduledTaskInitParameters struct {

	// Set shutdown hours for cluster object.
	ShutdownHours []ShutdownHoursInitParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	Tasks []TasksInitParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ScheduledTaskObservation struct {

	// Set shutdown hours for cluster object.
	ShutdownHours []ShutdownHoursObservation `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	Tasks []TasksObservation `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ScheduledTaskParameters struct {

	// Set shutdown hours for cluster object.
	// +kubebuilder:validation:Optional
	ShutdownHours []ShutdownHoursParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// The scheduling tasks for the cluster.
	// +kubebuilder:validation:Optional
	Tasks []TasksParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ShutdownHoursInitParameters struct {

	// Toggle the shutdown hours task. (Example: true).
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. Specify a list of timeWindows with at least one time window Each string is in the format of: ddd:hh:mm-ddd:hh:mm where ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, hh = hour 24 = 0 -23, mm = minute = 0 - 59. Time windows should not overlap. Required if cluster.scheduling.isEnabled is true. (Example: Fri:15:30-Wed:14:30).
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type ShutdownHoursObservation struct {

	// Toggle the shutdown hours task. (Example: true).
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. Specify a list of timeWindows with at least one time window Each string is in the format of: ddd:hh:mm-ddd:hh:mm where ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, hh = hour 24 = 0 -23, mm = minute = 0 - 59. Time windows should not overlap. Required if cluster.scheduling.isEnabled is true. (Example: Fri:15:30-Wed:14:30).
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type ShutdownHoursParameters struct {

	// Toggle the shutdown hours task. (Example: true).
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// Set time windows for shutdown hours. Specify a list of timeWindows with at least one time window Each string is in the format of: ddd:hh:mm-ddd:hh:mm where ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, hh = hour 24 = 0 -23, mm = minute = 0 - 59. Time windows should not overlap. Required if cluster.scheduling.isEnabled is true. (Example: Fri:15:30-Wed:14:30).
	// +kubebuilder:validation:Optional
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type TagsInitParameters struct {

	// The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsObservation struct {

	// The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsParameters struct {

	// The tag key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The tag value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type TasksInitParameters struct {

	// A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object. (Example: 0 1 * * *).
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Toggle the shutdown hours task. (Example: true).
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// This filed will be compatible to the task_type field. If task_type is defined as clusterRoll, user cluster roll object in parameters.
	Parameters []ParametersInitParameters `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Valid values: clusterRoll amiAutoUpdate. Required for cluster.scheduling.tasks
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type TasksObservation struct {

	// A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object. (Example: 0 1 * * *).
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Toggle the shutdown hours task. (Example: true).
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// This filed will be compatible to the task_type field. If task_type is defined as clusterRoll, user cluster roll object in parameters.
	Parameters []ParametersObservation `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Valid values: clusterRoll amiAutoUpdate. Required for cluster.scheduling.tasks
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type TasksParameters struct {

	// A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object. (Example: 0 1 * * *).
	// +kubebuilder:validation:Optional
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// Toggle the shutdown hours task. (Example: true).
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// This filed will be compatible to the task_type field. If task_type is defined as clusterRoll, user cluster roll object in parameters.
	// +kubebuilder:validation:Optional
	Parameters []ParametersParameters `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// Valid values: clusterRoll amiAutoUpdate. Required for cluster.scheduling.tasks
	// +kubebuilder:validation:Optional
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type UpdatePolicyInitParameters struct {

	// will update instance tags on the fly without rolling the cluster.
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the conditioned_roll parameter is set to true. (Valid values: "subnet_ids","whitelist","blacklist","user_data","image_id","security_groups","key_name","iam_instance_profile","associate_public_ip_address","load_balancers","instance_metadata_options","ebs_optimized","root_volume_size")
	ConditionedRollParams []*string `json:"conditionedRollParams,omitempty" tf:"conditioned_roll_params,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	RollConfig []RollConfigInitParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyObservation struct {

	// will update instance tags on the fly without rolling the cluster.
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the conditioned_roll parameter is set to true. (Valid values: "subnet_ids","whitelist","blacklist","user_data","image_id","security_groups","key_name","iam_instance_profile","associate_public_ip_address","load_balancers","instance_metadata_options","ebs_optimized","root_volume_size")
	ConditionedRollParams []*string `json:"conditionedRollParams,omitempty" tf:"conditioned_roll_params,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// will update instance tags on the fly without rolling the cluster.
	// +kubebuilder:validation:Optional
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the conditioned_roll parameter is set to true. (Valid values: "subnet_ids","whitelist","blacklist","user_data","image_id","security_groups","key_name","iam_instance_profile","associate_public_ip_address","load_balancers","instance_metadata_options","ebs_optimized","root_volume_size")
	// +kubebuilder:validation:Optional
	ConditionedRollParams []*string `json:"conditionedRollParams,omitempty" tf:"conditioned_roll_params,omitempty"`

	// While used, you can control whether the group should perform a deployment after an update to the configuration.
	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	// +kubebuilder:validation:Optional
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// OceanAwsSpec defines the desired state of OceanAws
type OceanAwsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanAwsParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OceanAwsInitParameters `json:"initProvider,omitempty"`
}

// OceanAwsStatus defines the observed state of OceanAws.
type OceanAwsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanAwsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OceanAws is the Schema for the OceanAwss API. Provides a Spotinst Ocean resource using AWS.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type OceanAws struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.imageId) || (has(self.initProvider) && has(self.initProvider.imageId))",message="spec.forProvider.imageId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.securityGroups) || (has(self.initProvider) && has(self.initProvider.securityGroups))",message="spec.forProvider.securityGroups is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.subnetIds) || (has(self.initProvider) && has(self.initProvider.subnetIds))",message="spec.forProvider.subnetIds is a required parameter"
	Spec   OceanAwsSpec   `json:"spec"`
	Status OceanAwsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAwsList contains a list of OceanAwss
type OceanAwsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanAws `json:"items"`
}

// Repository type metadata.
var (
	OceanAws_Kind             = "OceanAws"
	OceanAws_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanAws_Kind}.String()
	OceanAws_KindAPIVersion   = OceanAws_Kind + "." + CRDGroupVersion.String()
	OceanAws_GroupVersionKind = CRDGroupVersion.WithKind(OceanAws_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanAws{}, &OceanAwsList{})
}
