/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttachWorkloadsObservation struct {
	Namespaces []NamespacesObservation `json:"namespaces,omitempty" tf:"namespaces,omitempty"`
}

type AttachWorkloadsParameters struct {

	// +kubebuilder:validation:Required
	Namespaces []NamespacesParameters `json:"namespaces" tf:"namespaces,omitempty"`
}

type DetachWorkloadsNamespacesObservation struct {
	Labels []NamespacesLabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	NamespaceName *string `json:"namespaceName,omitempty" tf:"namespace_name,omitempty"`

	Workloads []NamespacesWorkloadsObservation `json:"workloads,omitempty" tf:"workloads,omitempty"`
}

type DetachWorkloadsNamespacesParameters struct {

	// +kubebuilder:validation:Optional
	Labels []NamespacesLabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	NamespaceName *string `json:"namespaceName" tf:"namespace_name,omitempty"`

	// +kubebuilder:validation:Optional
	Workloads []NamespacesWorkloadsParameters `json:"workloads,omitempty" tf:"workloads,omitempty"`
}

type DetachWorkloadsObservation struct {
	Namespaces []DetachWorkloadsNamespacesObservation `json:"namespaces,omitempty" tf:"namespaces,omitempty"`
}

type DetachWorkloadsParameters struct {

	// +kubebuilder:validation:Required
	Namespaces []DetachWorkloadsNamespacesParameters `json:"namespaces" tf:"namespaces,omitempty"`
}

type LabelsObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type MonthlyRepetitionBasisObservation struct {
	IntervalMonths []*float64 `json:"intervalMonths,omitempty" tf:"interval_months,omitempty"`

	WeekOfTheMonth []*string `json:"weekOfTheMonth,omitempty" tf:"week_of_the_month,omitempty"`

	WeeklyRepetitionBasis []WeeklyRepetitionBasisObservation `json:"weeklyRepetitionBasis,omitempty" tf:"weekly_repetition_basis,omitempty"`
}

type MonthlyRepetitionBasisParameters struct {

	// +kubebuilder:validation:Required
	IntervalMonths []*float64 `json:"intervalMonths" tf:"interval_months,omitempty"`

	// +kubebuilder:validation:Required
	WeekOfTheMonth []*string `json:"weekOfTheMonth" tf:"week_of_the_month,omitempty"`

	// +kubebuilder:validation:Optional
	WeeklyRepetitionBasis []WeeklyRepetitionBasisParameters `json:"weeklyRepetitionBasis,omitempty" tf:"weekly_repetition_basis,omitempty"`
}

type NamespacesLabelsObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NamespacesLabelsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type NamespacesObservation struct {
	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	NamespaceName *string `json:"namespaceName,omitempty" tf:"namespace_name,omitempty"`

	Workloads []WorkloadsObservation `json:"workloads,omitempty" tf:"workloads,omitempty"`
}

type NamespacesParameters struct {

	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	NamespaceName *string `json:"namespaceName" tf:"namespace_name,omitempty"`

	// +kubebuilder:validation:Optional
	Workloads []WorkloadsParameters `json:"workloads,omitempty" tf:"workloads,omitempty"`
}

type NamespacesWorkloadsObservation struct {
	RegexName *string `json:"regexName,omitempty" tf:"regex_name,omitempty"`

	WorkloadName *string `json:"workloadName,omitempty" tf:"workload_name,omitempty"`

	WorkloadType *string `json:"workloadType,omitempty" tf:"workload_type,omitempty"`
}

type NamespacesWorkloadsParameters struct {

	// +kubebuilder:validation:Optional
	RegexName *string `json:"regexName,omitempty" tf:"regex_name,omitempty"`

	// +kubebuilder:validation:Optional
	WorkloadName *string `json:"workloadName,omitempty" tf:"workload_name,omitempty"`

	// +kubebuilder:validation:Required
	WorkloadType *string `json:"workloadType" tf:"workload_type,omitempty"`
}

type RecommendationApplicationBoundariesObservation struct {
	CPUMax *float64 `json:"cpuMax,omitempty" tf:"cpu_max,omitempty"`

	CPUMin *float64 `json:"cpuMin,omitempty" tf:"cpu_min,omitempty"`

	MemoryMax *float64 `json:"memoryMax,omitempty" tf:"memory_max,omitempty"`

	MemoryMin *float64 `json:"memoryMin,omitempty" tf:"memory_min,omitempty"`
}

type RecommendationApplicationBoundariesParameters struct {

	// +kubebuilder:validation:Optional
	CPUMax *float64 `json:"cpuMax,omitempty" tf:"cpu_max,omitempty"`

	// +kubebuilder:validation:Optional
	CPUMin *float64 `json:"cpuMin,omitempty" tf:"cpu_min,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryMax *float64 `json:"memoryMax,omitempty" tf:"memory_max,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryMin *float64 `json:"memoryMin,omitempty" tf:"memory_min,omitempty"`
}

type RecommendationApplicationIntervalsObservation struct {
	MonthlyRepetitionBasis []MonthlyRepetitionBasisObservation `json:"monthlyRepetitionBasis,omitempty" tf:"monthly_repetition_basis,omitempty"`

	RepetitionBasis *string `json:"repetitionBasis,omitempty" tf:"repetition_basis,omitempty"`

	WeeklyRepetitionBasis []RecommendationApplicationIntervalsWeeklyRepetitionBasisObservation `json:"weeklyRepetitionBasis,omitempty" tf:"weekly_repetition_basis,omitempty"`
}

type RecommendationApplicationIntervalsParameters struct {

	// +kubebuilder:validation:Optional
	MonthlyRepetitionBasis []MonthlyRepetitionBasisParameters `json:"monthlyRepetitionBasis,omitempty" tf:"monthly_repetition_basis,omitempty"`

	// +kubebuilder:validation:Required
	RepetitionBasis *string `json:"repetitionBasis" tf:"repetition_basis,omitempty"`

	// +kubebuilder:validation:Optional
	WeeklyRepetitionBasis []RecommendationApplicationIntervalsWeeklyRepetitionBasisParameters `json:"weeklyRepetitionBasis,omitempty" tf:"weekly_repetition_basis,omitempty"`
}

type RecommendationApplicationIntervalsWeeklyRepetitionBasisObservation struct {
	IntervalDays []*string `json:"intervalDays,omitempty" tf:"interval_days,omitempty"`

	IntervalHoursEndTime *string `json:"intervalHoursEndTime,omitempty" tf:"interval_hours_end_time,omitempty"`

	IntervalHoursStartTime *string `json:"intervalHoursStartTime,omitempty" tf:"interval_hours_start_time,omitempty"`
}

type RecommendationApplicationIntervalsWeeklyRepetitionBasisParameters struct {

	// +kubebuilder:validation:Required
	IntervalDays []*string `json:"intervalDays" tf:"interval_days,omitempty"`

	// +kubebuilder:validation:Required
	IntervalHoursEndTime *string `json:"intervalHoursEndTime" tf:"interval_hours_end_time,omitempty"`

	// +kubebuilder:validation:Required
	IntervalHoursStartTime *string `json:"intervalHoursStartTime" tf:"interval_hours_start_time,omitempty"`
}

type RecommendationApplicationMinThresholdObservation struct {
	CPUPercentage *float64 `json:"cpuPercentage,omitempty" tf:"cpu_percentage,omitempty"`

	MemoryPercentage *float64 `json:"memoryPercentage,omitempty" tf:"memory_percentage,omitempty"`
}

type RecommendationApplicationMinThresholdParameters struct {

	// +kubebuilder:validation:Optional
	CPUPercentage *float64 `json:"cpuPercentage,omitempty" tf:"cpu_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPercentage *float64 `json:"memoryPercentage,omitempty" tf:"memory_percentage,omitempty"`
}

type RecommendationApplicationOverheadValuesObservation struct {
	CPUPercentage *float64 `json:"cpuPercentage,omitempty" tf:"cpu_percentage,omitempty"`

	MemoryPercentage *float64 `json:"memoryPercentage,omitempty" tf:"memory_percentage,omitempty"`
}

type RecommendationApplicationOverheadValuesParameters struct {

	// +kubebuilder:validation:Optional
	CPUPercentage *float64 `json:"cpuPercentage,omitempty" tf:"cpu_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPercentage *float64 `json:"memoryPercentage,omitempty" tf:"memory_percentage,omitempty"`
}

type RightSizingRuleObservation struct {
	AttachWorkloads []AttachWorkloadsObservation `json:"attachWorkloads,omitempty" tf:"attach_workloads,omitempty"`

	DetachWorkloads []DetachWorkloadsObservation `json:"detachWorkloads,omitempty" tf:"detach_workloads,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	RecommendationApplicationBoundaries []RecommendationApplicationBoundariesObservation `json:"recommendationApplicationBoundaries,omitempty" tf:"recommendation_application_boundaries,omitempty"`

	RecommendationApplicationIntervals []RecommendationApplicationIntervalsObservation `json:"recommendationApplicationIntervals,omitempty" tf:"recommendation_application_intervals,omitempty"`

	RecommendationApplicationMinThreshold []RecommendationApplicationMinThresholdObservation `json:"recommendationApplicationMinThreshold,omitempty" tf:"recommendation_application_min_threshold,omitempty"`

	RecommendationApplicationOverheadValues []RecommendationApplicationOverheadValuesObservation `json:"recommendationApplicationOverheadValues,omitempty" tf:"recommendation_application_overhead_values,omitempty"`

	RestartPods *bool `json:"restartPods,omitempty" tf:"restart_pods,omitempty"`

	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`
}

type RightSizingRuleParameters struct {

	// +kubebuilder:validation:Optional
	AttachWorkloads []AttachWorkloadsParameters `json:"attachWorkloads,omitempty" tf:"attach_workloads,omitempty"`

	// +kubebuilder:validation:Optional
	DetachWorkloads []DetachWorkloadsParameters `json:"detachWorkloads,omitempty" tf:"detach_workloads,omitempty"`

	// +kubebuilder:validation:Optional
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// +kubebuilder:validation:Optional
	RecommendationApplicationBoundaries []RecommendationApplicationBoundariesParameters `json:"recommendationApplicationBoundaries,omitempty" tf:"recommendation_application_boundaries,omitempty"`

	// +kubebuilder:validation:Optional
	RecommendationApplicationIntervals []RecommendationApplicationIntervalsParameters `json:"recommendationApplicationIntervals,omitempty" tf:"recommendation_application_intervals,omitempty"`

	// +kubebuilder:validation:Optional
	RecommendationApplicationMinThreshold []RecommendationApplicationMinThresholdParameters `json:"recommendationApplicationMinThreshold,omitempty" tf:"recommendation_application_min_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	RecommendationApplicationOverheadValues []RecommendationApplicationOverheadValuesParameters `json:"recommendationApplicationOverheadValues,omitempty" tf:"recommendation_application_overhead_values,omitempty"`

	// +kubebuilder:validation:Optional
	RestartPods *bool `json:"restartPods,omitempty" tf:"restart_pods,omitempty"`

	// +kubebuilder:validation:Optional
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`
}

type WeeklyRepetitionBasisObservation struct {
	IntervalDays []*string `json:"intervalDays,omitempty" tf:"interval_days,omitempty"`

	IntervalHoursEndTime *string `json:"intervalHoursEndTime,omitempty" tf:"interval_hours_end_time,omitempty"`

	IntervalHoursStartTime *string `json:"intervalHoursStartTime,omitempty" tf:"interval_hours_start_time,omitempty"`
}

type WeeklyRepetitionBasisParameters struct {

	// +kubebuilder:validation:Required
	IntervalDays []*string `json:"intervalDays" tf:"interval_days,omitempty"`

	// +kubebuilder:validation:Required
	IntervalHoursEndTime *string `json:"intervalHoursEndTime" tf:"interval_hours_end_time,omitempty"`

	// +kubebuilder:validation:Required
	IntervalHoursStartTime *string `json:"intervalHoursStartTime" tf:"interval_hours_start_time,omitempty"`
}

type WorkloadsObservation struct {
	RegexName *string `json:"regexName,omitempty" tf:"regex_name,omitempty"`

	WorkloadName *string `json:"workloadName,omitempty" tf:"workload_name,omitempty"`

	WorkloadType *string `json:"workloadType,omitempty" tf:"workload_type,omitempty"`
}

type WorkloadsParameters struct {

	// +kubebuilder:validation:Optional
	RegexName *string `json:"regexName,omitempty" tf:"regex_name,omitempty"`

	// +kubebuilder:validation:Optional
	WorkloadName *string `json:"workloadName,omitempty" tf:"workload_name,omitempty"`

	// +kubebuilder:validation:Required
	WorkloadType *string `json:"workloadType" tf:"workload_type,omitempty"`
}

// RightSizingRuleSpec defines the desired state of RightSizingRule
type RightSizingRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RightSizingRuleParameters `json:"forProvider"`
}

// RightSizingRuleStatus defines the observed state of RightSizingRule.
type RightSizingRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RightSizingRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RightSizingRule is the Schema for the RightSizingRules API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type RightSizingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.recommendationApplicationIntervals)",message="recommendationApplicationIntervals is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ruleName)",message="ruleName is a required parameter"
	Spec   RightSizingRuleSpec   `json:"spec"`
	Status RightSizingRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RightSizingRuleList contains a list of RightSizingRules
type RightSizingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RightSizingRule `json:"items"`
}

// Repository type metadata.
var (
	RightSizingRule_Kind             = "RightSizingRule"
	RightSizingRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RightSizingRule_Kind}.String()
	RightSizingRule_KindAPIVersion   = RightSizingRule_Kind + "." + CRDGroupVersion.String()
	RightSizingRule_GroupVersionKind = CRDGroupVersion.WithKind(RightSizingRule_Kind)
)

func init() {
	SchemeBuilder.Register(&RightSizingRule{}, &RightSizingRuleList{})
}
