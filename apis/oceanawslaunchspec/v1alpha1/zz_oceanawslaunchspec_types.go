/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoscaleDownObservation struct {

	// The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleDownParameters struct {

	// The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleHeadroomsAutomaticObservation struct {

	// Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.is_enabled = true is set on the Ocean cluster.
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`
}

type AutoscaleHeadroomsAutomaticParameters struct {

	// Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.is_enabled = true is set on the Ocean cluster.
	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`
}

type AutoscaleHeadroomsObservation struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomsParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	// +kubebuilder:validation:Required
	NumOfUnits *float64 `json:"numOfUnits" tf:"num_of_units,omitempty"`
}

type BlockDeviceMappingsObservation struct {

	// String. Set device name. (Example: /dev/xvda).
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Object. Set Elastic Block Store properties .
	EBS []EBSObservation `json:"ebs,omitempty" tf:"ebs,omitempty"`

	// String. Suppresses the specified device included in the block device mapping of the AMI.
	NoDevice *string `json:"noDevice,omitempty" tf:"no_device,omitempty"`

	// The name of the Virtual Node Group.
	VirtualName *string `json:"virtualName,omitempty" tf:"virtual_name,omitempty"`
}

type BlockDeviceMappingsParameters struct {

	// String. Set device name. (Example: /dev/xvda).
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Object. Set Elastic Block Store properties .
	// +kubebuilder:validation:Optional
	EBS []EBSParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`

	// String. Suppresses the specified device included in the block device mapping of the AMI.
	// +kubebuilder:validation:Optional
	NoDevice *string `json:"noDevice,omitempty" tf:"no_device,omitempty"`

	// The name of the Virtual Node Group.
	// +kubebuilder:validation:Optional
	VirtualName *string `json:"virtualName,omitempty" tf:"virtual_name,omitempty"`
}

type CreateOptionsObservation struct {

	// When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the use_as_template_only (in spotinst_ocean_aws resource) is set to true during Ocean resource creation.
	InitialNodes *float64 `json:"initialNodes,omitempty" tf:"initial_nodes,omitempty"`
}

type CreateOptionsParameters struct {

	// When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the use_as_template_only (in spotinst_ocean_aws resource) is set to true during Ocean resource creation.
	// +kubebuilder:validation:Optional
	InitialNodes *float64 `json:"initialNodes,omitempty" tf:"initial_nodes,omitempty"`
}

type DeleteOptionsObservation struct {

	// When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
	DeleteNodes *bool `json:"deleteNodes,omitempty" tf:"delete_nodes,omitempty"`

	// When set to true, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with useAsTemlateOnly = true). Should be set at creation or update, but will be used only at deletion.
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`
}

type DeleteOptionsParameters struct {

	// When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
	// +kubebuilder:validation:Optional
	DeleteNodes *bool `json:"deleteNodes,omitempty" tf:"delete_nodes,omitempty"`

	// When set to true, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with useAsTemlateOnly = true). Should be set at creation or update, but will be used only at deletion.
	// +kubebuilder:validation:Required
	ForceDelete *bool `json:"forceDelete" tf:"force_delete,omitempty"`
}

type DynamicVolumeSizeObservation struct {

	// Int. Initial size for volume. (Example: 50)
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB)
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicVolumeSizeParameters struct {

	// Int. Initial size for volume. (Example: 50)
	// +kubebuilder:validation:Required
	BaseSize *float64 `json:"baseSize" tf:"base_size,omitempty"`

	// String. Resource type to increase volume size dynamically by. (Valid values: CPU)
	// +kubebuilder:validation:Required
	Resource *string `json:"resource" tf:"resource,omitempty"`

	// Int. Additional size (in GB) per resource unit. (Example: baseSize=50, sizePerResourceUnit=20, and instance with 2 CPU is launched; its total disk size will be: 90GB)
	// +kubebuilder:validation:Required
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit" tf:"size_per_resource_unit,omitempty"`
}

type EBSObservation struct {

	// Boolean. Flag to delete the EBS on instance termination.
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
	DynamicVolumeSize []DynamicVolumeSizeObservation `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// Boolean. Enables EBS encryption on the volume.
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// Int. The number of I/O operations per second (IOPS) that the volume supports.
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// String. The Snapshot ID to mount by.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// The amount of data transferred to or from a storage device per second, you can use this param just in a case that volume_type = gp3.
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// Int. The size, in GB of the volume.
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// String. The type of the volume. (Example: gp2).
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type EBSParameters struct {

	// Boolean. Flag to delete the EBS on instance termination.
	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
	// +kubebuilder:validation:Optional
	DynamicVolumeSize []DynamicVolumeSizeParameters `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// Boolean. Enables EBS encryption on the volume.
	// +kubebuilder:validation:Optional
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// Int. The number of I/O operations per second (IOPS) that the volume supports.
	// +kubebuilder:validation:Optional
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// String. The Snapshot ID to mount by.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// The amount of data transferred to or from a storage device per second, you can use this param just in a case that volume_type = gp3.
	// +kubebuilder:validation:Optional
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// Int. The size, in GB of the volume.
	// +kubebuilder:validation:Optional
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// String. The type of the volume. (Example: gp2).
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ElasticIPPoolObservation struct {

	// A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
	TagSelector []TagSelectorObservation `json:"tagSelector,omitempty" tf:"tag_selector,omitempty"`
}

type ElasticIPPoolParameters struct {

	// A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
	// +kubebuilder:validation:Optional
	TagSelector []TagSelectorParameters `json:"tagSelector,omitempty" tf:"tag_selector,omitempty"`
}

type EphemeralStorageObservation struct {

	// Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
	EphemeralStorageDeviceName *string `json:"ephemeralStorageDeviceName,omitempty" tf:"ephemeral_storage_device_name,omitempty"`
}

type EphemeralStorageParameters struct {

	// Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
	// +kubebuilder:validation:Optional
	EphemeralStorageDeviceName *string `json:"ephemeralStorageDeviceName,omitempty" tf:"ephemeral_storage_device_name,omitempty"`
}

type ImagesObservation struct {

	// ID of the image used to launch the instances.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`
}

type ImagesParameters struct {

	// ID of the image used to launch the instances.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`
}

type InstanceMetadataOptionsObservation struct {

	// An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// Determines if a signed token is required or not. Valid values: optional or required.
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`
}

type InstanceMetadataOptionsParameters struct {

	// An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// Determines if a signed token is required or not. Valid values: optional or required.
	// +kubebuilder:validation:Required
	HTTPTokens *string `json:"httpTokens" tf:"http_tokens,omitempty"`
}

type InstanceTypesFiltersObservation struct {

	// The filtered instance types will belong to one of the categories types from this list. Valid values: Accelerated_computing, Compute_optimized, General_purpose, Memory_optimized, Storage_optimized.
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// The filtered instance types will have one of the disk type from this list. Valid values: NVMe, EBS, SSD, HDD.
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// In case excludeMetal is set to true, metal types will not be available for scaling.
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// The filtered instance types will have a hypervisor type from this list. Valid values: nitro, xen.
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Ena is supported or not.
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// Maximum total number of GPUs.
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum Bandwidth in Gib/s of network performance.
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// Maximum number of vcpus available.
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of network interfaces (ENIs).
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// Minimum total number of GPUs.
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum Bandwidth in Gib/s of network performance.
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// Minimum number of vcpus available.
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// The filtered instance types will have a root device types from this list. Valid values: ebs, or instance-store.
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// The filtered instance types will support at least one of the virtualization types from this list. Valid values: hvm, paravirtual.
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type InstanceTypesFiltersParameters struct {

	// The filtered instance types will belong to one of the categories types from this list. Valid values: Accelerated_computing, Compute_optimized, General_purpose, Memory_optimized, Storage_optimized.
	// +kubebuilder:validation:Optional
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// The filtered instance types will have one of the disk type from this list. Valid values: NVMe, EBS, SSD, HDD.
	// +kubebuilder:validation:Optional
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// In case excludeMetal is set to true, metal types will not be available for scaling.
	// +kubebuilder:validation:Optional
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// The filtered instance types will have a hypervisor type from this list. Valid values: nitro, xen.
	// +kubebuilder:validation:Optional
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
	// +kubebuilder:validation:Optional
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// Ena is supported or not.
	// +kubebuilder:validation:Optional
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// Maximum total number of GPUs.
	// +kubebuilder:validation:Optional
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// Maximum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// Maximum Bandwidth in Gib/s of network performance.
	// +kubebuilder:validation:Optional
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// Maximum number of vcpus available.
	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// Minimum number of network interfaces (ENIs).
	// +kubebuilder:validation:Optional
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// Minimum total number of GPUs.
	// +kubebuilder:validation:Optional
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// Minimum amount of Memory (GiB).
	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// Minimum Bandwidth in Gib/s of network performance.
	// +kubebuilder:validation:Optional
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// Minimum number of vcpus available.
	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// The filtered instance types will have a root device types from this list. Valid values: ebs, or instance-store.
	// +kubebuilder:validation:Optional
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// The filtered instance types will support at least one of the virtualization types from this list. Valid values: hvm, paravirtual.
	// +kubebuilder:validation:Optional
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type LabelsObservation struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// The label key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The label value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type OceanAwsLaunchSpecObservation struct {

	// Configure public IP address allocation.
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// Auto Scaling scale down operations.
	AutoscaleDown []AutoscaleDownObservation `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// Set custom headroom per Virtual Node Group. Provide a list of headrooms object.
	AutoscaleHeadrooms []AutoscaleHeadroomsObservation `json:"autoscaleHeadrooms,omitempty" tf:"autoscale_headrooms,omitempty"`

	// Set automatic headroom per launch spec.
	AutoscaleHeadroomsAutomatic []AutoscaleHeadroomsAutomaticObservation `json:"autoscaleHeadroomsAutomatic,omitempty" tf:"autoscale_headrooms_automatic,omitempty"`

	// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
	BlockDeviceMappings []BlockDeviceMappingsObservation `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	CreateOptions []CreateOptionsObservation `json:"createOptions,omitempty" tf:"create_options,omitempty"`

	DeleteOptions []DeleteOptionsObservation `json:"deleteOptions,omitempty" tf:"delete_options,omitempty"`

	// Assign an Elastic IP to the instances spun by the Virtual Node Group. Can be null.
	ElasticIPPool []ElasticIPPoolObservation `json:"elasticIpPool,omitempty" tf:"elastic_ip_pool,omitempty"`

	EphemeralStorage []EphemeralStorageObservation `json:"ephemeralStorage,omitempty" tf:"ephemeral_storage,omitempty"`

	// The ARN or name of an IAM instance profile to associate with launched instances.
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// The Virtual Node Group ID.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// ID of the image used to launch the instances.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// Array of objects (Image object, containing the id of the image used to launch instances.) You can configure VNG with either the imageId or images objects, but not both simultaneously.
	// For each architecture type (amd64, arm64) only one AMI is allowed. Valid values: null, or an array with at least one element.
	Images []ImagesObservation `json:"images,omitempty" tf:"images,omitempty"`

	// Ocean instance metadata options object for IMDSv2.
	InstanceMetadataOptions []InstanceMetadataOptionsObservation `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// A list of instance types allowed to be provisioned for pods pending under the specified launch specification. The list overrides the list defined for the cluster.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance types that match with all filters compose the Virtual Node Group's instanceTypes parameter.
	// The architectures that come from the Virtual Node Group's images will be taken into account when using this parameter. Cannot be configured together with Virtual Node Group's instanceTypes and with the Cluster's whitelist/blacklist/filters.
	InstanceTypesFilters []InstanceTypesFiltersObservation `json:"instanceTypesFilters,omitempty" tf:"instance_types_filters,omitempty"`

	// Optionally adds labels to instances launched in the cluster.
	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of the Virtual Node Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the Ocean cluster.
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	PreferredOdTypes []*string `json:"preferredOdTypes,omitempty" tf:"preferred_od_types,omitempty"`

	// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
	PreferredSpotTypes []*string `json:"preferredSpotTypes,omitempty" tf:"preferred_spot_types,omitempty"`

	ResourceLimits []ResourceLimitsObservation `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`

	// Boolean. When set to True, nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
	RestrictScaleDown *bool `json:"restrictScaleDown,omitempty" tf:"restrict_scale_down,omitempty"`

	// Set root volume size (in GB).
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Used to specify times that the nodes in the virtual node group will be taken down.
	SchedulingShutdownHours []SchedulingShutdownHoursObservation `json:"schedulingShutdownHours,omitempty" tf:"scheduling_shutdown_hours,omitempty"`

	// Used to define scheduled tasks such as a manual headroom update.
	SchedulingTask []SchedulingTaskObservation `json:"schedulingTask,omitempty" tf:"scheduling_task,omitempty"`

	// Optionally adds security group IDs.
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	Strategy []StrategyObservation `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// A list of subnet IDs.
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// A key/value mapping of tags to assign to the resource.
	Tags []TagsObservation `json:"tags,omitempty" tf:"tags,omitempty"`

	// Optionally adds labels to instances launched in the cluster.
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// Base64-encoded MIME user data to make available to the instances.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type OceanAwsLaunchSpecParameters struct {

	// Configure public IP address allocation.
	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// Auto Scaling scale down operations.
	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// Set custom headroom per Virtual Node Group. Provide a list of headrooms object.
	// +kubebuilder:validation:Optional
	AutoscaleHeadrooms []AutoscaleHeadroomsParameters `json:"autoscaleHeadrooms,omitempty" tf:"autoscale_headrooms,omitempty"`

	// Set automatic headroom per launch spec.
	// +kubebuilder:validation:Optional
	AutoscaleHeadroomsAutomatic []AutoscaleHeadroomsAutomaticParameters `json:"autoscaleHeadroomsAutomatic,omitempty" tf:"autoscale_headrooms_automatic,omitempty"`

	// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	// +kubebuilder:validation:Optional
	CreateOptions []CreateOptionsParameters `json:"createOptions,omitempty" tf:"create_options,omitempty"`

	// +kubebuilder:validation:Optional
	DeleteOptions []DeleteOptionsParameters `json:"deleteOptions,omitempty" tf:"delete_options,omitempty"`

	// Assign an Elastic IP to the instances spun by the Virtual Node Group. Can be null.
	// +kubebuilder:validation:Optional
	ElasticIPPool []ElasticIPPoolParameters `json:"elasticIpPool,omitempty" tf:"elastic_ip_pool,omitempty"`

	// +kubebuilder:validation:Optional
	EphemeralStorage []EphemeralStorageParameters `json:"ephemeralStorage,omitempty" tf:"ephemeral_storage,omitempty"`

	// The ARN or name of an IAM instance profile to associate with launched instances.
	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// ID of the image used to launch the instances.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// Array of objects (Image object, containing the id of the image used to launch instances.) You can configure VNG with either the imageId or images objects, but not both simultaneously.
	// For each architecture type (amd64, arm64) only one AMI is allowed. Valid values: null, or an array with at least one element.
	// +kubebuilder:validation:Optional
	Images []ImagesParameters `json:"images,omitempty" tf:"images,omitempty"`

	// Ocean instance metadata options object for IMDSv2.
	// +kubebuilder:validation:Optional
	InstanceMetadataOptions []InstanceMetadataOptionsParameters `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// A list of instance types allowed to be provisioned for pods pending under the specified launch specification. The list overrides the list defined for the cluster.
	// +kubebuilder:validation:Optional
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance types that match with all filters compose the Virtual Node Group's instanceTypes parameter.
	// The architectures that come from the Virtual Node Group's images will be taken into account when using this parameter. Cannot be configured together with Virtual Node Group's instanceTypes and with the Cluster's whitelist/blacklist/filters.
	// +kubebuilder:validation:Optional
	InstanceTypesFilters []InstanceTypesFiltersParameters `json:"instanceTypesFilters,omitempty" tf:"instance_types_filters,omitempty"`

	// Optionally adds labels to instances launched in the cluster.
	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of the Virtual Node Group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The ID of the Ocean cluster.
	// +kubebuilder:validation:Optional
	OceanID *string `json:"oceanId,omitempty" tf:"ocean_id,omitempty"`

	// +kubebuilder:validation:Optional
	PreferredOdTypes []*string `json:"preferredOdTypes,omitempty" tf:"preferred_od_types,omitempty"`

	// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
	// +kubebuilder:validation:Optional
	PreferredSpotTypes []*string `json:"preferredSpotTypes,omitempty" tf:"preferred_spot_types,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`

	// Boolean. When set to True, nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
	// +kubebuilder:validation:Optional
	RestrictScaleDown *bool `json:"restrictScaleDown,omitempty" tf:"restrict_scale_down,omitempty"`

	// Set root volume size (in GB).
	// +kubebuilder:validation:Optional
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// Used to specify times that the nodes in the virtual node group will be taken down.
	// +kubebuilder:validation:Optional
	SchedulingShutdownHours []SchedulingShutdownHoursParameters `json:"schedulingShutdownHours,omitempty" tf:"scheduling_shutdown_hours,omitempty"`

	// Used to define scheduled tasks such as a manual headroom update.
	// +kubebuilder:validation:Optional
	SchedulingTask []SchedulingTaskParameters `json:"schedulingTask,omitempty" tf:"scheduling_task,omitempty"`

	// Optionally adds security group IDs.
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy []StrategyParameters `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// A list of subnet IDs.
	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// A key/value mapping of tags to assign to the resource.
	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// Optionally adds labels to instances launched in the cluster.
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// Base64-encoded MIME user data to make available to the instances.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type ResourceLimitsObservation struct {

	// Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
	MaxInstanceCount *float64 `json:"maxInstanceCount,omitempty" tf:"max_instance_count,omitempty"`

	// Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
	MinInstanceCount *float64 `json:"minInstanceCount,omitempty" tf:"min_instance_count,omitempty"`
}

type ResourceLimitsParameters struct {

	// Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
	// +kubebuilder:validation:Optional
	MaxInstanceCount *float64 `json:"maxInstanceCount,omitempty" tf:"max_instance_count,omitempty"`

	// Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
	// +kubebuilder:validation:Optional
	MinInstanceCount *float64 `json:"minInstanceCount,omitempty" tf:"min_instance_count,omitempty"`
}

type RollConfigObservation struct {

	// Sets the percentage of the instances to deploy in each batch.
	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`
}

type RollConfigParameters struct {

	// Sets the percentage of the instances to deploy in each batch.
	// +kubebuilder:validation:Required
	BatchSizePercentage *float64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`
}

type SchedulingShutdownHoursObservation struct {

	// Describes whether the task is enabled. When True, the task runs. When False, it does not run.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The times that the shutdown hours will apply.
	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type SchedulingShutdownHoursParameters struct {

	// Describes whether the task is enabled. When True, the task runs. When False, it does not run.
	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The times that the shutdown hours will apply.
	// +kubebuilder:validation:Required
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type SchedulingTaskObservation struct {

	// A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	// Describes whether the task is enabled. When True, the task runs. When False, it does not run.
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// The config of this scheduled task. Depends on the value of taskType.
	TaskHeadroom []TaskHeadroomObservation `json:"taskHeadroom,omitempty" tf:"task_headroom,omitempty"`

	// The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type SchedulingTaskParameters struct {

	// A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
	// +kubebuilder:validation:Required
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// Describes whether the task is enabled. When True, the task runs. When False, it does not run.
	// +kubebuilder:validation:Required
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// The config of this scheduled task. Depends on the value of taskType.
	// +kubebuilder:validation:Optional
	TaskHeadroom []TaskHeadroomParameters `json:"taskHeadroom,omitempty" tf:"task_headroom,omitempty"`

	// The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type StrategyObservation struct {

	// The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`
}

type StrategyParameters struct {

	// The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
	// +kubebuilder:validation:Optional
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`
}

type TagSelectorObservation struct {

	// Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
	TagKey *string `json:"tagKey,omitempty" tf:"tag_key,omitempty"`

	// Elastic IP tag value. Can be null.
	TagValue *string `json:"tagValue,omitempty" tf:"tag_value,omitempty"`
}

type TagSelectorParameters struct {

	// Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
	// +kubebuilder:validation:Required
	TagKey *string `json:"tagKey" tf:"tag_key,omitempty"`

	// Elastic IP tag value. Can be null.
	// +kubebuilder:validation:Optional
	TagValue *string `json:"tagValue,omitempty" tf:"tag_value,omitempty"`
}

type TagsObservation struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsParameters struct {

	// The label key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The label value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TaintsObservation struct {

	// The effect of the taint. Valid values: "NoSchedule", "PreferNoSchedule", "NoExecute".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// The effect of the taint. Valid values: "NoSchedule", "PreferNoSchedule", "NoExecute".
	// +kubebuilder:validation:Required
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// The label key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The label value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TaskHeadroomObservation struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type TaskHeadroomParameters struct {

	// Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// Optionally configure the number of GPUS to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
	// +kubebuilder:validation:Required
	NumOfUnits *float64 `json:"numOfUnits" tf:"num_of_units,omitempty"`
}

type UpdatePolicyObservation struct {

	// Holds the roll configuration.
	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// Holds the roll configuration.
	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// Enables the roll.
	// +kubebuilder:validation:Required
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// OceanAwsLaunchSpecSpec defines the desired state of OceanAwsLaunchSpec
type OceanAwsLaunchSpecSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OceanAwsLaunchSpecParameters `json:"forProvider"`
}

// OceanAwsLaunchSpecStatus defines the observed state of OceanAwsLaunchSpec.
type OceanAwsLaunchSpecStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OceanAwsLaunchSpecObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAwsLaunchSpec is the Schema for the OceanAwsLaunchSpecs API. Provides a Spotinst Virtual Node Group resource using AWS.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spot}
type OceanAwsLaunchSpec struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.oceanId)",message="oceanId is a required parameter"
	Spec   OceanAwsLaunchSpecSpec   `json:"spec"`
	Status OceanAwsLaunchSpecStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OceanAwsLaunchSpecList contains a list of OceanAwsLaunchSpecs
type OceanAwsLaunchSpecList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OceanAwsLaunchSpec `json:"items"`
}

// Repository type metadata.
var (
	OceanAwsLaunchSpec_Kind             = "OceanAwsLaunchSpec"
	OceanAwsLaunchSpec_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OceanAwsLaunchSpec_Kind}.String()
	OceanAwsLaunchSpec_KindAPIVersion   = OceanAwsLaunchSpec_Kind + "." + CRDGroupVersion.String()
	OceanAwsLaunchSpec_GroupVersionKind = CRDGroupVersion.WithKind(OceanAwsLaunchSpec_Kind)
)

func init() {
	SchemeBuilder.Register(&OceanAwsLaunchSpec{}, &OceanAwsLaunchSpecList{})
}
